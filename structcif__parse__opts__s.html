<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: cif_parse_opts_s Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="functions.html"><span>Data&nbsp;Fields</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>cif_parse_opts_s Struct Reference<br/>
<small>
[<a class="el" href="group__datatypes.html">Data types</a>]</small>
</h1><!-- doxytag: class="cif_parse_opts_s" -->
<p>Represents a collection of CIF parsing options.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;cif.h&gt;</code></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a2d39a63d7655f7951a9899bd9e3cc24c">prefer_cif2</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Influences the parser's selection of CIF 1 or CIF 2 format to handle a CIF stream.  <a href="#a2d39a63d7655f7951a9899bd9e3cc24c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a98d672990d6a6b0a94044421256b660b">default_encoding_name</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If not <code>NULL</code> , names the coded character set with which the parser will attempt to interpret plain CIF 1.1 "text" files that do not bear recognized encoding information.  <a href="#a98d672990d6a6b0a94044421256b660b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a9c5a0a54dee1d77cc9c5531d6993f0b8">force_default_encoding</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If non-zero then the default encoding specified by <code>default_encoding_name</code> will be used to interpret the CIF 1.1 or 2.0 input, regardless of any encoding signature or other appearance to the contrary.  <a href="#a9c5a0a54dee1d77cc9c5531d6993f0b8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#adaa4b6e4c63ae97ff4047cb873aca57a">line_folding_modifier</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifies whether line-folded text fields will be recognized and unfolded during parsing.  <a href="#adaa4b6e4c63ae97ff4047cb873aca57a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#aa19fa312b8df3b00182551008063d147">text_prefixing_modifier</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Modifies whether prefixed text fields will be recognized and de-prefixed during parsing.  <a href="#aa19fa312b8df3b00182551008063d147"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a4fd9296d96520881a0138891f795d05e">max_frame_depth</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The maximum save frame depth.  <a href="#a4fd9296d96520881a0138891f795d05e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a726ecc2a60cc011824e395a70957c07f">extra_ws_chars</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ASCII characters that should be interpreted as CIF inline whitespace.  <a href="#a726ecc2a60cc011824e395a70957c07f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a75cba35666a09ce2861f31fe948c6acf">extra_eol_chars</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">ASCII characters that should be interpreted as CIF end-of-line [whitespace] characters.  <a href="#a75cba35666a09ce2861f31fe948c6acf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcif__handler__s.html">cif_handler_tp</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a4508b10109b811a30c950500a9234cfe">handler</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A set of handler functions by which the application can be notified of details of the parse progress as they occur, and through which it can influence the data recorded; may be <code>NULL</code>.  <a href="#a4508b10109b811a30c950500a9234cfe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#ac879b3d626898f828809e15e52c995e1">whitespace_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function by which the client application can be notified about whitespace that is not an inherent part of any data value.  <a href="#ac879b3d626898f828809e15e52c995e1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a509366eafb1690727b681a95662d92c4">keyword_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function by which the client application can be notified about CIF keywords.  <a href="#a509366eafb1690727b681a95662d92c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#aec8a029e2eb8829d5cf9d5fbc08c3023">dataname_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function by which the client application can be notified about CIF data names as they are encountered.  <a href="#aec8a029e2eb8829d5cf9d5fbc08c3023"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga9bd06e152cfd90deb050f3c926cf31be">cif_parse_error_callback_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a96747877315cb02b78779f862ca86d1e">error_callback</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A callback function by which the client application can be notified about parse errors, affording it the option to interrupt the parse or allow it to continue.  <a href="#a96747877315cb02b78779f862ca86d1e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66b7d5cb3d1244e724a7f15aa9b02c4f"></a><!-- doxytag: member="cif_parse_opts_s::user_data" ref="a66b7d5cb3d1244e724a7f15aa9b02c4f" args="" -->
void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcif__parse__opts__s.html#a66b7d5cb3d1244e724a7f15aa9b02c4f">user_data</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A pointer to user data to be forwarded to all callback functions invoked by the parser; opaque to the parser itself, and may be <code>NULL</code>. <br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Represents a collection of CIF parsing options. </p>
<p>Unlike most data types defined by the CIF API, the parse options are not opaque. This reflects the <code>struct's</code> intended use for collecting (only) user-settable option values. There is nevertheless still an object creation function, <code><a class="el" href="group__cifio__funcs.html#ga9a62365d8a9c9c000b6c3871ef3879d1" title="Allocates a parse options structure and initializes it with default values.">cif_parse_options_create()</a></code> ; applications allocating parse options only via that function will thereby insulate themselves against changes to the struct's size arising from additions to the option list in future versions of the API. </p>
<hr/><h2>Field Documentation</h2>
<a class="anchor" id="aec8a029e2eb8829d5cf9d5fbc08c3023"></a><!-- doxytag: member="cif_parse_opts_s::dataname_callback" ref="aec8a029e2eb8829d5cf9d5fbc08c3023" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a> <a class="el" href="structcif__parse__opts__s.html#aec8a029e2eb8829d5cf9d5fbc08c3023">cif_parse_opts_s::dataname_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function by which the client application can be notified about CIF data names as they are encountered. </p>
<p>If not <code>NULL</code>, this function will be called by the parser whenever it encounters a data name in the input CIF. before it is reported as part of a loop or individual data item. </p>

</div>
</div>
<a class="anchor" id="a98d672990d6a6b0a94044421256b660b"></a><!-- doxytag: member="cif_parse_opts_s::default_encoding_name" ref="a98d672990d6a6b0a94044421256b660b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structcif__parse__opts__s.html#a98d672990d6a6b0a94044421256b660b">cif_parse_opts_s::default_encoding_name</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If not <code>NULL</code> , names the coded character set with which the parser will attempt to interpret plain CIF 1.1 "text" files that do not bear recognized encoding information. </p>
<p>Inasmuch as CIF 1 is a text format and CIF 2.0 is a text-like format, it is essential for the parser to interpret them according to the text encodings with which they are written. Well-formed CIF 2.0 is Unicode text encoded via UTF-8, but the CIF 1 specifications are intentionally vague about the terms "text" and "text file", intending them to be interpreted in a system-dependent manner. Additionally, documents that conform to CIF 2.0 except with respect to encoding can still be parsed successfully (though an error will be flagged) if the correct encoding can be determined.</p>
<p>The parser will recognize UTF-8, UTF-16 (either byte order), and UTF-32 (either of two byte orders) for CIFs that begin with a Unicode byte-order mark (BOM). In most cases it will recognize UTF-16 and UTF-32 encodings even without a BOM, as well. In some cases it may recognize UTF-8 or other encodings when there is no BOM, and well-formed CIF 2.0 documents will always be recognized as UTF-8 (also wrongly-encoded CIF 2.0 documents may be interpreted as UTF-8).</p>
<p>If no encoding is specified via this option (i.e. it is <code>NULL</code> ) and no encoding signature is recognized in the input CIF, then for CIF 1.1 documents the parser will choose a default text encoding that is appropriate to the system on which it is running, and it will attempt to parse according to that encoding. How the default encoding is chosen is implementation dependent in this case.</p>
<p>If the correct encoding of the input CIF is known, however, then that encoding can be specified by its IANA name via this option. Implementations may also recognize aliases and / or unregistered encoding names. If it is supported, the named encoding will be used in the event that no encoding signature is detected, bypassing the library's usual method for choosing a default encoding. This allows a CIF written in a localized encoding to be parsed correctly on a system with a different default locale. It should be noted, however, that such a CIF can reasonably be considered erroneous (on the system where it is being parsed) on account of its encoding.</p>
<p>The names supported by this option are those recognized by ICU's "converter" API as converter / code page names. </p>

</div>
</div>
<a class="anchor" id="a96747877315cb02b78779f862ca86d1e"></a><!-- doxytag: member="cif_parse_opts_s::error_callback" ref="a96747877315cb02b78779f862ca86d1e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga9bd06e152cfd90deb050f3c926cf31be">cif_parse_error_callback_tp</a> <a class="el" href="structcif__parse__opts__s.html#a96747877315cb02b78779f862ca86d1e">cif_parse_opts_s::error_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function by which the client application can be notified about parse errors, affording it the option to interrupt the parse or allow it to continue. </p>
<p>If not <code>NULL</code>, this function will be called by the parser whenever it encounters an error in the input CIF. The parse will be aborted immediately with an error if this function returns non-zero; otherwise, it serves informational purposes only. Two pre-built error callbacks are provided: <code><a class="el" href="group__cifio__funcs.html#ga496775864901244b64abcc63fe2bbb5a" title="A CIF parse error handler function that ignores all errors.">cif_parse_error_ignore()</a></code> and <code><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98" title="A CIF parse error handler function that interrupts the parse on any error, returning...">cif_parse_error_die()</a></code>.</p>
<p>If <code>NULL</code>, or if parse options are not specified, then the parser will operate as if the error handler were <code><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98" title="A CIF parse error handler function that interrupts the parse on any error, returning...">cif_parse_error_die()</a></code>. </p>

</div>
</div>
<a class="anchor" id="a75cba35666a09ce2861f31fe948c6acf"></a><!-- doxytag: member="cif_parse_opts_s::extra_eol_chars" ref="a75cba35666a09ce2861f31fe948c6acf" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structcif__parse__opts__s.html#a75cba35666a09ce2861f31fe948c6acf">cif_parse_opts_s::extra_eol_chars</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ASCII characters that should be interpreted as CIF end-of-line [whitespace] characters. </p>
<p>If not <code>NULL</code>, specifies additional characters from the 7-bit ASCII set and / or from among the C1 controls that should be accepted as representing CIF end-of-line characters. Ordinarily, only the carriage return and newline characters have this function, and the C1 controls and most of the C0 controls are disallowed altogether. This option is mainly intended to allow successful parsing of pre-v1.1 CIFs, some of which used the form feed character as an end-of-line character, but it is not inherently limited to that use.</p>
<p>Extra end-of-line characters appearing within data values are subject to the same conversion to newlines as carriage return characters and carriage return / line feed pairs.</p>
<p>The space and tab characters cannot be given end-of-line significance via this option; if they appear in the provided string then they are ignored.</p>
<p>The carriage return and newline characters may be specified among these characters, but it has no additional effect.</p>
<p>The string is terminated by a null character (<code>'\0'</code>); no mechanism is provided for treating that character as end-of-line. </p>

</div>
</div>
<a class="anchor" id="a726ecc2a60cc011824e395a70957c07f"></a><!-- doxytag: member="cif_parse_opts_s::extra_ws_chars" ref="a726ecc2a60cc011824e395a70957c07f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="structcif__parse__opts__s.html#a726ecc2a60cc011824e395a70957c07f">cif_parse_opts_s::extra_ws_chars</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>ASCII characters that should be interpreted as CIF inline whitespace. </p>
<p>If not <code>NULL</code>, specifies additional characters from the 7-bit ASCII set and / or from among the C1 controls that should be accepted as representing CIF inline whitespace. Ordinarily, only the space character and the tab character have this function, and the C1 controls and most of the C0 controls are disallowed altogether. This option is mainly intended to allow successful parsing of pre-v1.1 CIFs, some of which used the vertical tab character as inline whitespace, but it is not inherently limited to that use.</p>
<p>The space or tab may be specified among these characters, but it has no additional effect.</p>
<p>The carriage return and newline characters may be specified among these characters, but it does not change their role as end-of-line characters.</p>
<p>The string is terminated by a null character (<code>'\0'</code>); no mechanism is provided for treating that character as whitespace. </p>

</div>
</div>
<a class="anchor" id="a9c5a0a54dee1d77cc9c5531d6993f0b8"></a><!-- doxytag: member="cif_parse_opts_s::force_default_encoding" ref="a9c5a0a54dee1d77cc9c5531d6993f0b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcif__parse__opts__s.html#a9c5a0a54dee1d77cc9c5531d6993f0b8">cif_parse_opts_s::force_default_encoding</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>If non-zero then the default encoding specified by <code>default_encoding_name</code> will be used to interpret the CIF 1.1 or 2.0 input, regardless of any encoding signature or other appearance to the contrary. </p>
<p>If <code>default_encoding_name</code> is NULL then it represents a system-dependent default encoding. That's the norm for CIF 1.1 input anyway, but if <code>force_default_encoding</code> is nonzero then the same system-dependent default will be chosen for CIF 2.0 as well.</p>
<p>This option is dangerous. Enabling it can cause CIF parsing to fail, or in some cases cause CIF contents to silently be misinterpreted, if the specified default encoding is not in fact the correct encoding for the input. On the other hand, use of this option is essential for correctly parsing CIF documents whose encoding cannot be determined or guessed correctly.</p>
<p>This option can be used to parse CIF 2.0 text that is encoded other than via UTF-8. Such a file is not valid CIF 2.0, and therefore will cause an error to be flagged, but if the error is ignored and the specified encoding is in fact correct for the input then parsing will otherwise proceed normally. </p>

</div>
</div>
<a class="anchor" id="a4508b10109b811a30c950500a9234cfe"></a><!-- doxytag: member="cif_parse_opts_s::handler" ref="a4508b10109b811a30c950500a9234cfe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcif__handler__s.html">cif_handler_tp</a>* <a class="el" href="structcif__parse__opts__s.html#a4508b10109b811a30c950500a9234cfe">cif_parse_opts_s::handler</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A set of handler functions by which the application can be notified of details of the parse progress as they occur, and through which it can influence the data recorded; may be <code>NULL</code>. </p>
<p>If not itself NULL, then any non-null handler functions in the <code>cif_handler_tp</code> to which this option points will be invoked by the parser at appropriate times as it traverses the input CIF text. The handlers' return codes <code>CIF_TRAVERSE_SKIP_CURRENT</code> and <code>CIF_TRAVERSE_SKIP_SIBLINGS</code> are interpreted as directing which data to record in the target CIF, if indeed the user has provided one. (The parser cannot altogether skip parsing any part of the input if it must identify the end of that part and there resume normal operation.) Handler callbacks are not invoked for entities thereby passed over. Handlers may modify the CIF under construction, subject to the limitations inherent in the CIF being incompletely constructed when they are called. </p>

</div>
</div>
<a class="anchor" id="a509366eafb1690727b681a95662d92c4"></a><!-- doxytag: member="cif_parse_opts_s::keyword_callback" ref="a509366eafb1690727b681a95662d92c4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a> <a class="el" href="structcif__parse__opts__s.html#a509366eafb1690727b681a95662d92c4">cif_parse_opts_s::keyword_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function by which the client application can be notified about CIF keywords. </p>
<p>If not <code>NULL</code>, this function will be called by the parser whenever it encounters a CIF keyword that does not directly correspond to or trigger a CIF Handler callback. At this version, that is only the 'loop_' keyword, but a future version may also signal other keywords, so callback functions attached to this hook should check which keyword they receive if in fact they care. </p>

</div>
</div>
<a class="anchor" id="adaa4b6e4c63ae97ff4047cb873aca57a"></a><!-- doxytag: member="cif_parse_opts_s::line_folding_modifier" ref="adaa4b6e4c63ae97ff4047cb873aca57a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcif__parse__opts__s.html#adaa4b6e4c63ae97ff4047cb873aca57a">cif_parse_opts_s::line_folding_modifier</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifies whether line-folded text fields will be recognized and unfolded during parsing. </p>
<p>The line-folding protocol for text fields is part of the CIF 2.0 specification, but it is only a common convention for CIF 1. By default, therefore, the parser will recognize and unfold line-folded text fields when it operates in CIF 2.0 mode, but it will pass them through as-is when it operates in CIF 1.0 mode. This option influences that behavior: if greater than zero then the parser will unfold line-folded text fields regardless of CIF version, and if less than zero then it will <em>not</em> recognize or unfold line-folded text fields even in CIF 2 mode.</p>
<p>Note that where a text field has been both line-folded and prefixed, the line-folding can be recognized only if line unfolding and text de-prefixing are <em>both</em> enabled. </p>

</div>
</div>
<a class="anchor" id="a4fd9296d96520881a0138891f795d05e"></a><!-- doxytag: member="cif_parse_opts_s::max_frame_depth" ref="a4fd9296d96520881a0138891f795d05e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcif__parse__opts__s.html#a4fd9296d96520881a0138891f795d05e">cif_parse_opts_s::max_frame_depth</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The maximum save frame depth. </p>
<p>If 1, then one level of save frames will be accepted (i.e. save frames are allowed, but must not be nested). If 0 then all save frames will be rejected as erroneous. That might be used to ensure that CIF data files (as opposed to dictionaries) do not contain save frames. If negative, then save frames are allowed, and may be nested without limit. Values greater than 1 are <b>reserved</b> for possible future use as a bound on save frame nesting depth.</p>
<p>The current version of STAR allows nested save frames, and their use was proposed for CIF 2, especially for DDLm dictionaries. Save frame nesting was not accepted into the CIF 2.0 standard, however, even for dictionary files.</p>
<p>The default is 1. </p>

</div>
</div>
<a class="anchor" id="a2d39a63d7655f7951a9899bd9e3cc24c"></a><!-- doxytag: member="cif_parse_opts_s::prefer_cif2" ref="a2d39a63d7655f7951a9899bd9e3cc24c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcif__parse__opts__s.html#a2d39a63d7655f7951a9899bd9e3cc24c">cif_parse_opts_s::prefer_cif2</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Influences the parser's selection of CIF 1 or CIF 2 format to handle a CIF stream. </p>
<p>Because the CIF-version code is <em>required</em> in CIF 2 but optional in CIF 1, it is most correct to assume CIF 1 when there is no version code. Nevertheless, if a CIF is known or assumed to otherwise comply with CIF2, then it is desirable to parse it that way regardless of the absence of a version code.</p>
<p>CIF 2 streams that erroneously omit the version code will be parsed as CIF 2 if this option has value greater than zero (albeit with an error on account of the missing version code). On the other hand, CIF 1 streams that (allowably) omit the version code may be parsed incorrectly if this option is enabled.</p>
<p>Moreover, CIF streams will be parsed as CIF 2 regardless of an explicit version code to the contrary if this option has a value of 20 or greater, and they will be parsed as CIF 1.1 regardless of an explicit version code to the contrary if this option has a value less than zero. </p>

</div>
</div>
<a class="anchor" id="aa19fa312b8df3b00182551008063d147"></a><!-- doxytag: member="cif_parse_opts_s::text_prefixing_modifier" ref="aa19fa312b8df3b00182551008063d147" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="structcif__parse__opts__s.html#aa19fa312b8df3b00182551008063d147">cif_parse_opts_s::text_prefixing_modifier</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Modifies whether prefixed text fields will be recognized and de-prefixed during parsing. </p>
<p>The prefix protocol for text fields is part of the CIF 2.0 specification, but for CIF 1 it is only a local convention of certain organizations. By default, therefore, the parser will recognize and de-prefix prefixed text fields when it operates in CIF 2.0 mode, but it will pass them through as-is when it operates in CIF 1.0 mode. This option influences that behavior: if greater than zero then the parser will de-prefix prefixed text fields regardless of CIF version, and if less than zero then it will <em>not</em> recognize or de-prefix prefixed text fields even in CIF 2 mode.</p>
<p>Note that where a text field has been both line-folded and prefixed, the prefixing can be recognized only if line unfolding and text de-prefixing are <em>both</em> enabled. </p>

</div>
</div>
<a class="anchor" id="ac879b3d626898f828809e15e52c995e1"></a><!-- doxytag: member="cif_parse_opts_s::whitespace_callback" ref="ac879b3d626898f828809e15e52c995e1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga36d7b2ac245b84e630ba8488c24c7c43">cif_syntax_callback_tp</a> <a class="el" href="structcif__parse__opts__s.html#ac879b3d626898f828809e15e52c995e1">cif_parse_opts_s::whitespace_callback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>A callback function by which the client application can be notified about whitespace that is not an inherent part of any data value. </p>
<p>If not <code>NULL</code>, this function will be called by the parser whenever it encounters a run of insignificant whitespace (including comments) in the input CIF. Whitespace is insignificant if it serves only to separate other elements appearing in the CIF.</p>
<p>The parser does not guarantee to collect <em>maximal</em> whitespace runs; it may at times split consecutive whitespace into multiple runs, performing a callback for each one. It does, however, mark each transition from whitespace to non-whitespace by reporting a zero-length whitespace run. It does so, too, for <em>virtual</em> whitespace -- where optional whitespace is omitted, or where the parser detects and recovers from omission of required whitespace. </p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

