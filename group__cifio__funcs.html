<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: CIF input / output functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CIF input / output functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c">cif_parse</a> (FILE *stream, struct <a class="el" href="structcif__parse__opts__s.html">cif_parse_opts_s</a> *options, <a class="el" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731">cif_tp</a> **cif)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses a CIF from the specified stream using the library's built-in parser.  <a href="#gaa63c92a58e9b58d368b161bd0741d64c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#ga9a62365d8a9c9c000b6c3871ef3879d1">cif_parse_options_create</a> (struct <a class="el" href="structcif__parse__opts__s.html">cif_parse_opts_s</a> **opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a parse options structure and initializes it with default values.  <a href="#ga9a62365d8a9c9c000b6c3871ef3879d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga496775864901244b64abcc63fe2bbb5a"></a><!-- doxytag: member="cifio_funcs::cif_parse_error_ignore" ref="ga496775864901244b64abcc63fe2bbb5a" args="(int code, size_t line, size_t column, const UChar *text, size_t length, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#ga496775864901244b64abcc63fe2bbb5a">cif_parse_error_ignore</a> (int code, size_t line, size_t column, const UChar *text, size_t length, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A CIF parse error handler function that ignores all errors. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0b6868dbab8cb460f2afa55b0f6e9e98"></a><!-- doxytag: member="cifio_funcs::cif_parse_error_die" ref="ga0b6868dbab8cb460f2afa55b0f6e9e98" args="(int code, size_t line, size_t column, const UChar *text, size_t length, void *data)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98">cif_parse_error_die</a> (int code, size_t line, size_t column, const UChar *text, size_t length, void *data)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A CIF parse error handler function that interrupts the parse on any error, returning <code>code</code>. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#ga2623bda284e6edccd4917d0089b58085">cif_write</a> (FILE *stream, struct <a class="el" href="structcif__write__opts__s.html">cif_write_opts_s</a> *options, <a class="el" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731">cif_tp</a> *cif)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Formats the CIF data represented by the <code>cif</code> handle to the specified output stream.  <a href="#ga2623bda284e6edccd4917d0089b58085"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__cifio__funcs.html#gaf305c41886816092a23cdb09b36c73fe">cif_write_options_create</a> (struct <a class="el" href="structcif__write__opts__s.html">cif_write_opts_s</a> **opts)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates a write options structure and initializes it with default values.  <a href="#gaf305c41886816092a23cdb09b36c73fe"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa63c92a58e9b58d368b161bd0741d64c"></a><!-- doxytag: member="cif.h::cif_parse" ref="gaa63c92a58e9b58d368b161bd0741d64c" args="(FILE *stream, struct cif_parse_opts_s *options, cif_tp **cif)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_parse </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcif__parse__opts__s.html">cif_parse_opts_s</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731">cif_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>cif</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parses a CIF from the specified stream using the library's built-in parser. </p>
<p>The data are interpreted as a standalone CIF providing zero or more data blocks to add to the provided or a new managed CIF object. The caller asserts that the new and any pre-existing data are part of the same logical CIF data set, therefore it constitutes a parse error for any data blocks in the provided CIF to have block codes that match that of one of the existing blocks.</p>
<p>If a new CIF object is created via this function then the caller assumes responsibility for releasing its resources at an appropriate time via <code><a class="el" href="group__whole__cif__funcs.html#ga4781ccd52bdc70271b44e6648f3ea41a" title="Removes the specified managed CIF, releasing all resources it holds.">cif_destroy()</a></code>.</p>
<p><b>CIF</b> <b>handler</b> <b>callbacks</b>. The parse options allow the caller to register a variety of callback functions by which the parse can be tracked and influenced. Most of these are wrapped together in the <code>handler</code> option, by which a <code>cif_handler_tp</code> object can be provided. Handler functions belonging to such a handler will be called when appropriate during CIF parsing, and the returned navigational signals direct which parts of the input data are included in the in-memory CIF rpresentation, if any, constructed by the parse. To some extent, the CIF can be modified during parse time, too; for example, loop categories may be assigned via callback.</p>
<p><b>Error</b> <b>handler</b> <b>callback</b>. The parse options also afford the caller an opportunity to specify an error-handler callback. The provided function will be invoked whenever any error is detected in the CIF input, and any return code other than <code>CIF_OK</code> will be immediately returned to the <code><a class="el" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&#39;s built-in parser.">cif_parse()</a></code> caller, aborting the remainder of the parse. This feature can be used to record or display information about the errors encountered, and / or to selectively ignore some errors (invoking the built-in recovery approach). Two pre-built error callbacks are provided: <code><a class="el" href="group__cifio__funcs.html#ga496775864901244b64abcc63fe2bbb5a" title="A CIF parse error handler function that ignores all errors.">cif_parse_error_ignore()</a></code> and <code><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98" title="A CIF parse error handler function that interrupts the parse on any error, returning...">cif_parse_error_die()</a></code>. If no error handler is specified by the caller then <code><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98" title="A CIF parse error handler function that interrupts the parse on any error, returning...">cif_parse_error_die()</a></code> is used.</p>
<p><b>Syntax-only</b> <b>mode</b>. If the <em>cif</em> argument is NULL then the parse is performed in syntax-only mode. Errors in CIF syntax will be detected as normal, but some semantic errors, such as duplicate data names, frame codes, or block codes will not be detected. Also, the handles provided to CIF handler functions during the parse may be NULL or may yield less information in this mode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>a <code>FILE</code> <code>*</code> from which to read the raw CIF data; must be a non-NULL pointer to a readable stream, which will typically be read to its end. This stream should be open in <b>BINARY</b> mode (e.g. fopen() mode "rb") on any system where that makes a difference. The caller retains ownership of this stream.</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options</em>&nbsp;</td><td>a pointer to a <code>struct</code> <code><a class="el" href="structcif__parse__opts__s.html" title="Represents a collection of CIF parsing options.">cif_parse_opts_s</a></code> object describing options to use while parsing, or <code>NULL</code> to use default values for all options</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>cif</em>&nbsp;</td><td>controls the disposition of the parsed data. If NULL, then the parsed data are discarded. Otherwise, they are added to the CIF to which this pointer refers. If a NULL handle is initially recorded at the referenced location then a new CIF is created to receive the data and its handle is recorded here. In the latter case, ownership of the new CIF goes to the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on a successful parse, even if the results are discarded, or an error code (typically <code>CIF_ERROR</code> ) on failure. In the event of a failure, a new CIF object may still be created and returned via the <code>cif</code> argument, or the provided CIF object may still be modified. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9a62365d8a9c9c000b6c3871ef3879d1"></a><!-- doxytag: member="cif.h::cif_parse_options_create" ref="ga9a62365d8a9c9c000b6c3871ef3879d1" args="(struct cif_parse_opts_s **opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_parse_options_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcif__parse__opts__s.html">cif_parse_opts_s</a> **&nbsp;</td>
          <td class="paramname"> <em>opts</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a parse options structure and initializes it with default values. </p>
<p>Obtaining a parse options structure via this function insulates programs against additions to the option list in future versions of the library. Programs may create <code><a class="el" href="structcif__parse__opts__s.html" title="Represents a collection of CIF parsing options.">cif_parse_opts_s</a></code> objects by other means -- for example, by allocating them on the stack -- but the behavior of programs that do may be undefined if they are dynamically linked against a future version of the library that adds fields to the structure definition, perhaps even if they are re-compiled against revised library headers. This is not an issue for statically-linked programs that fully initialize their options.</p>
<p>On successful return, the provided options object belongs to the caller. An options structure as provided by this function may safely be freed, or its members overwritten, without concern for freeing memory referenced by the members. The user is responsible for accommodating any deviation from those characteristics that are introduced to the structure after this function provides it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>opts</em>&nbsp;</td><td>a the location where a pointer to the new parse options structure should be recorded. The initial value of <code>*opts</code> is ignored, and is overwritten on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success or an error code (typically <code>CIF_ERROR</code> ) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2623bda284e6edccd4917d0089b58085"></a><!-- doxytag: member="cif.h::cif_write" ref="ga2623bda284e6edccd4917d0089b58085" args="(FILE *stream, struct cif_write_opts_s *options, cif_tp *cif)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_write </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcif__write__opts__s.html">cif_write_opts_s</a> *&nbsp;</td>
          <td class="paramname"> <em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731">cif_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>cif</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Formats the CIF data represented by the <code>cif</code> handle to the specified output stream. </p>
<p>By default, the output is in CIF 2.0 format, but the write options can be used to request CIF 1.1 format instead. These extra considerations apply to CIF 1.1 output mode: </p>
<ul>
<li>In CIF 1.1 mode, any data names, values, block codes, or frame codes in the provided CIF that cannot be expressed in CIF 1.1 will be be rejected, causing this function to fail. </li>
<li>The CIF 1.1 dialect written by this function is also well-formed CIF 2.0, except for the CIF-version header and possibly the encoding. In particular, it employs the line-folding protocol both to represent data values with extremely long lines, and to escape multi-line values that otherwise would be misinterpreted as employing the line-folding protocol and / or the text prefix protocol by a parser that recognizes those protocols (including function <code><a class="el" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&#39;s built-in parser.">cif_parse()</a></code>). As a result, however, parsers that <em>do</em> <em>not</em> recognize the line folding protocol may interpret some of the resulting values differently than was intended.</li>
</ul>
<p>Ownership of the arguments does not transfer to the function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>stream</em>&nbsp;</td><td>a <code>FILE</code> <code>*</code> to which to write the CIF format output; must be a non-NULL pointer to a writable stream. In the event that the write options request CIF 1.1 output, this file should be open in <em>text</em> mode (on those systems that have distinct text and binary modes)</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>options</em>&nbsp;</td><td>a pointer to a <code>struct</code> <code><a class="el" href="structcif__write__opts__s.html" title="Represents a collection of CIF writing options.">cif_write_opts_s</a></code> object describing options to use for writing, or <code>NULL</code> to use default values for all options</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cif</em>&nbsp;</td><td>a handle on the CIF object to serialize to the specified stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> if the data are fully written, or else an error code (typically <code>CIF_ERROR</code>, or <code>CIF_DISALLOWED_CHAR</code> or <code>CIF_DISALLOWED_VALUE</code> in CIF 1.1 mode). The stream state is undefined after a failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf305c41886816092a23cdb09b36c73fe"></a><!-- doxytag: member="cif.h::cif_write_options_create" ref="gaf305c41886816092a23cdb09b36c73fe" args="(struct cif_write_opts_s **opts)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_write_options_create </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcif__write__opts__s.html">cif_write_opts_s</a> **&nbsp;</td>
          <td class="paramname"> <em>opts</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates a write options structure and initializes it with default values. </p>
<p>Obtaining a write options structure via this function insulates programs against additions to the option list in future versions of the library. Programs may create <code><a class="el" href="structcif__write__opts__s.html" title="Represents a collection of CIF writing options.">cif_write_opts_s</a></code> objects by other means -- for example, by allocating them on the stack -- but the behavior of programs that do is undefined if they are dynamically linked against a future version of this API that adds fields to the structure definition. Statically-linked programs that fully initialize their write options structures are not subject to such issues.</p>
<p>On successful return, the provided options object belongs to the caller. An options structure as provided by this function may safely be freed, or its members overwritten, without concern for freeing memory referenced by the members. The user is responsible for accommodating any deviation from those characteristics that are introduced to the structure after this function provides it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>opts</em>&nbsp;</td><td>a the location where a pointer to the new write options structure should be recorded. The initial value of <code>*opts</code> is ignored, and is overwritten on success.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success or an error code (typically <code>CIF_ERROR</code> ) on failure. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

