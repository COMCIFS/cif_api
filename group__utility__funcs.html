<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: CIF utility functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CIF utility functions</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__funcs.html#gad72b7cf8afec5cdc75aef93ef9060105">cif_get_api_version</a> (char **version)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Provides a string representation of the CIF API's version number.  <a href="#gad72b7cf8afec5cdc75aef93ef9060105"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">UChar *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__funcs.html#ga405c52efd872866bcfd052c825f736a3">cif_u_strdup</a> (const UChar *str)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates and returns a duplicate of a Unicode string.  <a href="#ga405c52efd872866bcfd052c825f736a3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__funcs.html#ga94b6c9f08ede96c5538e07eef3b2f22e">cif_normalize</a> (const UChar *src, int32_t srclen, UChar **normalized)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts (the initial part of) the specified Unicode string to a case-folded normalized form.  <a href="#ga94b6c9f08ede96c5538e07eef3b2f22e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__utility__funcs.html#ga095e890fd85be7294b3caaaadef75268">cif_cstr_to_ustr</a> (const char *cstr, int32_t srclen, UChar **ustr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Converts (the initial part of) a C String to a Unicode string via an ICU default converter.  <a href="#ga095e890fd85be7294b3caaaadef75268"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga095e890fd85be7294b3caaaadef75268"></a><!-- doxytag: member="cif.h::cif_cstr_to_ustr" ref="ga095e890fd85be7294b3caaaadef75268" args="(const char *cstr, int32_t srclen, UChar **ustr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_cstr_to_ustr </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>cstr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>ustr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts (the initial part of) a C String to a Unicode string via an ICU default converter. </p>
<p>This function is most applicable to C strings obtained from external input, rather than to strings appearing in C source code. ICU will normally try to guess what converter is appropriate for default text, but the converter it will use can be influenced via <code>ucnv_setDefaultName()</code> (warning: the default converter name is <em>global</em>). On successful conversion, the output Unicode string will be NUL terminated.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cstr</em>&nbsp;</td><td>the C string to convert; may be NULL, in which case the conversion result is likewise NULL; if not NULL and <code>srclen</code> is -1, then must be terminated by a NUL byte, else termination is optional </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>srclen</em>&nbsp;</td><td>the input string length, or -1 if the string consists of all bytes up to a NUL terminator </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ustr</em>&nbsp;</td><td>a pointer to a location to record the result; must not be NULL. If a non-NULL pointer is written here by this function (which can happen only on success), then the caller assumes ownership of the memory it references.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gad72b7cf8afec5cdc75aef93ef9060105"></a><!-- doxytag: member="cif.h::cif_get_api_version" ref="gad72b7cf8afec5cdc75aef93ef9060105" args="(char **version)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_get_api_version </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>version</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Provides a string representation of the CIF API's version number. </p>
<p>Creates a character array, fills it with a string representation of the CIF API's version number, and records a pointer to it where the argument points. The caller is responsible for freeing the version string when it is no longer needed.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>version</em>&nbsp;</td><td>a pointer to location where a pointer to the version string should be recorded; must not be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>CIF_OK</code> on success, <code>CIF_ARGUMENT_ERROR</code> if <code>version</code> is <code>NULL</code>, or <code>CIF_MEMORY_ERROR</code> if space cannot be allocated for the version string </dd></dl>

</div>
</div>
<a class="anchor" id="ga94b6c9f08ede96c5538e07eef3b2f22e"></a><!-- doxytag: member="cif.h::cif_normalize" ref="ga94b6c9f08ede96c5538e07eef3b2f22e" args="(const UChar *src, int32_t srclen, UChar **normalized)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_normalize </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srclen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>normalized</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Converts (the initial part of) the specified Unicode string to a case-folded normalized form. </p>
<p>The normalized form is that obtained by converting to Unicode normalization form NFD, applying the Unicode case-folding algorithm to the result (with default handling of Turkic dotless i), and renormalizing the case-folded form to Unicode normalization form NFC. The result string, if provided, becomes the responsibility of the caller. If not NULL, it is guaranteed to be NUL-terminated.</p>
<p>The normalized form output by this function is suitable for comparing CIF "case-insensitive" strings for equivalence, as equivalent strings will have identical normalized forms. This accounts not only for case folding itself, but also for combining marks, including sequences thereof. It does not, however, erase distinctions between different Unicode characters that are typically rendered similarly (so-called "compatibility equivalents"), as that would constitute a semantic change.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>the Unicode string to normalize; must not be NULL </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>srclen</em>&nbsp;</td><td>the maximum length of the input to normalize; if less than zero then the whole string is normalized up to the first NUL character (which otherwise does not need to be present); must not exceed the actual number of UChars in the source string </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>normalized</em>&nbsp;</td><td>a pointer to a location to record the result; if NULL then the result is discarded, but the return code still indicates whether normalization was successful. If non-NULL, then the pointer at the specified location is overwritten, and the caller assumes responsibility for freeing the memory to which the new value points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga405c52efd872866bcfd052c825f736a3"></a><!-- doxytag: member="cif.h::cif_u_strdup" ref="ga405c52efd872866bcfd052c825f736a3" args="(const UChar *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">UChar* cif_u_strdup </td>
          <td>(</td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>str</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and returns a duplicate of a Unicode string. </p>
<p>It is sometimes useful to duplicate a Unicode string, but ICU does not provide an analog of <code>strdup()</code> for that purpose. The CIF API therefore provides its own, and makes it available for general use.</p>
<p>Behavior is undefined if the argument is not terminated by a NUL (Unicode) character.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>str</em>&nbsp;</td><td>the NUL-terminated Unicode string to duplicate; the caller retains ownership of this object</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a pointer to the duplicate, or NULL on failure or if the argument is NULL. Responsibility for the duplicate, if any, belongs to the caller. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

