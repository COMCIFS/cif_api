<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: CIF Application Programming Interface and Reference Implementation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>CIF Application Programming Interface and Reference Implementation</h1><h3>0.4.0 </h3><h2><a class="anchor" id="introduction">
Introduction</a></h2>
<p>These pages document a standard C library for manipulating Crytallographic Information Framework / File (CIF) data, consisting of two parts: </p>
<ul>
<li>opaque data types, function specifications, constants, and macro definitions jointly constituting an <em>interface</em> between programs that consume, manipulate, and produce CIF data and an underlying support library, and </li>
<li>an <em>implementation</em> of the interface functions and data types.</li>
</ul>
<p>Only the interface portion is proposed as a COMCIFS-sanctioned standard; the reference implementation is provided to validate the form and clarify the intent of the interface specifications. In other words, it is both proof of concept and reference implementation. Nevertheless, the the implementation is sufficiently stable and robust for general use.</p>
<p>This initiative arose from a COMCIFS resolution adopted at the 2011 triennial conference of the International Union of Crystallography (IUCr). The intent was to create a standard programming interface for interacting with CIF data, especially in light of the changes and additions arriving in CIF 2.0. The working group tasked with the project chose an approach whereby multiple common programming languages could be bound to the same underlying API, instead of a family of separate, language-specific APIs being defined. The best <em>lingua franca</em> for that purpose is standard C, so the API and reference implementation are written in a C form that is compliant with C89, C99, and C2011, as well as with C++98 and C++2011.</p>
<p>No API specifically supporting validation is defined as part of this effort, though the parsing API contains hooks that could be used to attach trans-parse validation functions. Inasmuch as CIF validation is specific to the relevant DDL, which is out of scope for this API, the extent of specific validation support that may be implemented in any future release is unclear.</p>
<h2><a class="anchor" id="concepts">
Concepts</a></h2>
<p>Beyond general CIF concepts (see <em>Internationhal Tables for Crystallography, Vol G</em>, Hall &amp; McMahon eds.) and additions and extensions brought by CIF 2.0, the CIF API has a few additional concepts that users and developers should understand.</p>
<h3><a class="anchor" id="management">
Managed CIFs</a></h3>
<p>The CIF API takes a somewhat abstract approach to CIF data. Instead of focusing on its representation as a (structured) text file or character stream, it focuses on the logical structure of the data: a CIF as a collection of top-level data containers (data blocks) with one level of nested containers (save frames) and in the containers data consisting of identifiers (data names) with one or more associated values, optionally organized into possibly-repeating groups (loops).</p>
<p>That kind of abstraction is by no means novel, but the important and perhaps distinguishing point is that the interface definitions intentionally do not specify the internal form of the data. The documentation therefore uses the generic term "managed" to describe the data that the core CIF manipulation functions operate upon, which is implementation dependent. The author imagines that most implementations will use some kind of in-memory form separate from any source file, but implementations that operate directly on physical files are conceivable and allowed. Thus, where the documentation describes "managed" CIFs or CIF sub-objects, it is referring to whatever form and location the implementation treats as its working space.</p>
<h3><a class="anchor" id="opaque">
Opaque Data Structures</a></h3>
<p>To provide a measure of implementation-independence and to facilitate future improvements and extensions, the provided interfaces use opaque data structures as a general rule. User code does not have full definitions of these structures, and therefore it can create or manipulate them only via the provided interface functions. Although this approach is constraining in some ways, it also frees users to program at a somewhat higher level of abstraction.</p>
<h3><a class="anchor" id="handles">
Handles</a></h3>
<p>As an outgrowth of opaque data structures and managed CIFs, the API uses the concept of "handles" on managed CIFs and parts of them. These are pointers to data structures that represent various CIF parts, but do not necessarily contain the data directly and/or are not the primary managed storage for that data. For example, in an API implementation that used a file-based representation of managed data, the handle on a data block might contain an offset into the file of the start of that block. The handle on a whole cif might contain a stream pointer, or perhaps just a file name.</p>
<p>Not all data objects in the API are handles, however; data value and packet objects in particular are ordinary data (though the actual data structures are still opaque).</p>
<h3><a class="anchor" id="oo">
Object Orientation</a></h3>
<p>One of the outcomes of using opaque data structures is a generally object-oriented approach to the interface specifications, in plain C. Most functions can be considered methods of some object type, taking a pointer to an instance of that type as their first argument (or a pointer to a pointer in the case of creation functions), and it is primarily via such functions (methods) that users interact with their data. This OO character follows from the API design objectives; it is not an independent objective of its own.</p>
<h3><a class="anchor" id="resources">
Resource Management</a></h3>
<p>C programmers will be well aware of resource management issues. The CIF API does not relieve programmers of all resource management responsibilities, but it does strive to make them straightforward and approachable. Among the ways it handles those problems are: </p>
<ul>
<li>documenting resource management responsibilities and responsibility transfers associated with the various functions; </li>
<li>providing necessary resource management functions (<code>cif_*_free</code>() and in some cases <code>cif_*_clean</code>() ); </li>
<li>preferring to copy data to avoid aliasing, so that management responsibilities remain clear; which allows that </li>
<li>composite objects taking responsibility for managing their components</li>
</ul>
<h3><a class="anchor" id="unicode">
Unicode</a></h3>
<p>CIF 2.0 expands the CIF character repertoire to all of Unicode, therefore the API must provide for representing Unicode text in data names, data values, block codes, and frame codes. Moreover, not only this API but <em>any</em> software that manipulates CIF 2.0 data as anything other than flat text must be prepared for added complications in ensuring "unique" and "case-insensitive" strings, and in matching user-provided strings against them.</p>
<p>For its low-level Unicode data representation, the CIF API explicitly relies on the data types (mainly <code>UChar</code> ) provided by the mature <a href="http://site.icu-project.org/">ICU project</a>. Developers wishing to write programs using the CIF API will certainly need the ICU development files. Furthermore, it is expected that implementations will generally use at least a few ICU library functions, therefore programs using the CIF API will typically need the ICU libraries at run time (unless they are statically linked in).</p>
<p>API users will frequently run into function arguments that are specified to be "Unicode strings", typically specified to be (and <em>always</em> expected to be) "NUL-terminated". These are analogous to traditional C strings, but with units of type <code>UChar</code> instead of the traditional <code>char</code> . Using <code>UChar</code> units instead of <code>char</code> units for Unicode strings makes working with Unicode strings fairly natural, especially with the ICU library's analogs of most of the familiar C string functions. Users may need to be aware, however, that this form is an encoding of Unicode in UTF-16 (with native byte order). In particular, characters outside the Unicode "basic multilingual plane" are represented via two consecutive <code>UChar</code> units drawn from special ranges (a "surrogate pair" in Unicode terminology). "NUL-terminated" refers to using a trailing sentinel value to mark the end of a string; as in traditional strings, the sentinel is the NUL character, which has code point (numeric value) 0. Unlike in traditional strings, however, <code>UChar</code> is a 16-bit (minimum) type, so a single 0 <em>byte</em> is not sufficient to end a Unicode string. Indeed, it is common for Unicode strings to contain isolated internal <code>0</code> bytes.</p>
<p>When matching "case insensitive" strings for lookup or uniqueness-checking purposes, the API uses a normalized form obtained by first converting the original string to Unicode normalization form NFD, then applying the Unicode case folding algorithm to the result, and finally converting the folded text to Unicode normalization form NFC. The procedure is suggested in Unicode's own discussion of the problem, which notes that it has the necessary property that if its output is fed back as input, then the same output is reproduced. It also has the desired property that any two character sequences that correspond to the same printed text will have the same normalized form under the algorithm, which the case-folding algorithm alone does not ensure. COMCIFS has approved use of this normalized form for evaluating "case-insensitive" string matching in CIF.</p>
<h2><a class="anchor" id="rights">
Rights and License</a></h2>
<p>The CIF API, including, but not limited to, documentation, interface definition, and reference implementation, is the copyrighted property of John Bollinger.</p>
<p>The CIF API is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>The CIF API is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with the CIF API. If not, see &lt;<a href="http://www.gnu.org/licenses">http://www.gnu.org/licenses</a>&gt;. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

