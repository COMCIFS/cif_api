<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: Functions for manipulating value objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Functions for manipulating value objects</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga3fe1a17cd35418767eaefd343f926e0b">cif_value_create</a> (<a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a> kind, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allocates and initializes a new value object of the specified kind.  <a href="#ga3fe1a17cd35418767eaefd343f926e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46">cif_value_clean</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees any resources associated with the provided value object without freeing the object itself, changing it into an instance of the explicit unknown value.  <a href="#gac6eb6d7ad6225498e56c89ee225c2c46"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gae023e5c1166c8f457333d776686a8f30">cif_value_free</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Frees the specified value object and all resources associated with it.  <a href="#gae023e5c1166c8f457333d776686a8f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga19562573b8a23de41705f0c15caefd9a">cif_value_clone</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **clone)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates an independent copy of a CIF value object.  <a href="#ga19562573b8a23de41705f0c15caefd9a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga332f27466b5af3f5d829394dbd803047">cif_value_init</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, <a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a> kind)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reinitializes the provided value object to a default value of the specified kind.  <a href="#ga332f27466b5af3f5d829394dbd803047"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga3be5dea8ed4231d7b9ae0859f886e025">cif_value_init_char</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, UChar *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)initializes the specified value object as being of kind <code>CIF_CHAR_KIND</code>, with the specified text  <a href="#ga3be5dea8ed4231d7b9ae0859f886e025"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga8be8921146e46ffe018892db81cbb107">cif_value_copy_char</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, const UChar *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with a copy of the specified text.  <a href="#ga8be8921146e46ffe018892db81cbb107"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga60c575d2fa5b5f0d83ab4d212e73e1ad">cif_value_parse_numb</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *numb, UChar *text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parses the specified Unicode string to produce a floating-point number and its standard uncertainty, recording them in the provided value object.  <a href="#ga60c575d2fa5b5f0d83ab4d212e73e1ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga80b0017214727b7fd841de3b90db8fa2">cif_value_init_numb</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *numb, double val, double su, int scale, int max_leading_zeroes)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)initializes the given value as a number with the specified value and uncertainty, with a number of significant figures determined by the specified <code>scale</code>  <a href="#ga80b0017214727b7fd841de3b90db8fa2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gacd228b9e592c6be981df3cea02176319">cif_value_autoinit_numb</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *numb, double val, double su, unsigned int su_rule)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(Re)initializes the given value as a number with the specified value and uncertainty, automatically choosing the number of significant digits to keep based on the specified <code>su</code> and <code>su_rule</code>.  <a href="#gacd228b9e592c6be981df3cea02176319"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gadc69676873c55ee05aa0b06bf8b16364">cif_value_kind</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the kind code of the specified value.  <a href="#gadc69676873c55ee05aa0b06bf8b16364"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__datatypes.html#gab312e9783ea613a434d4ef928a1513a1">cif_quoted_tp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga91436bec5f43ed8627871d5eea6192a6">cif_value_is_quoted</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns whether the value should be interpreted as if it were presented quoted.  <a href="#ga91436bec5f43ed8627871d5eea6192a6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c">cif_value_set_quoted</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, <a class="el" href="group__datatypes.html#gab312e9783ea613a434d4ef928a1513a1">cif_quoted_tp</a> quoted)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets whether the value should be interpreted as if it were presented quoted.  <a href="#gafa57153e1fc82f0891c354bff3b42a6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga5d0671fa297a3db716b824dc3fc5396c">cif_value_get_number</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *numb, double *val)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the value represented by the given number value object.  <a href="#ga5d0671fa297a3db716b824dc3fc5396c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gaf260b314e086bdc6e01650432e3c0c0a">cif_value_get_su</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *numb, double *su)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the uncertainty of the value represented by the given number value object.  <a href="#gaf260b314e086bdc6e01650432e3c0c0a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga7e6ce5f64d8099ad2cbcfe6453d1b492">cif_value_get_text</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, UChar **text)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves the text representation of the specified value.  <a href="#ga7e6ce5f64d8099ad2cbcfe6453d1b492"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gadceedc42c126d2634f68a85e4881753e">cif_value_get_element_count</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, size_t *count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the number of elements of a composite data value.  <a href="#gadceedc42c126d2634f68a85e4881753e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga5a832500e93ac0a60365b9b314fd26c4">cif_value_get_element_at</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, size_t index, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an element of a list value by its index.  <a href="#ga5a832500e93ac0a60365b9b314fd26c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga890298d11a6153e47bd22a306c7b71af">cif_value_set_element_at</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, size_t index, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Replaces an existing element of a list value with a different value.  <a href="#ga890298d11a6153e47bd22a306c7b71af"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gafe734d235d79b15ec1ca88fb0f7f194a">cif_value_insert_element_at</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, size_t index, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inserts an element into the specified list value at the specified position, pushing back the elements (if any) initially at that and following positions.  <a href="#gafe734d235d79b15ec1ca88fb0f7f194a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gae15adcee11ef627922f04786ff00c43f">cif_value_remove_element_at</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *value, size_t index, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an existing element from a list value, optionally returning it to the caller.  <a href="#gae15adcee11ef627922f04786ff00c43f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gaaf36b5e373b50c8e1b0c1faf9651cc22">cif_value_get_keys</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *table, const UChar ***keys)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieves an array of the keys of a table value.  <a href="#gaaf36b5e373b50c8e1b0c1faf9651cc22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gaced5bb916c9734b4d0799e131cbd3221">cif_value_set_item_by_key</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *table, const UChar *key, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *item)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates a specified value and key in the provided table value.  <a href="#gaced5bb916c9734b4d0799e131cbd3221"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#gaf58f82f1280c46bc214f07f2a16ecf9e">cif_value_get_item_by_key</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *table, const UChar *key, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Looks up a table entry by key and optionally returns the associated value.  <a href="#gaf58f82f1280c46bc214f07f2a16ecf9e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__value__funcs.html#ga67366971f91389a49d9b9523e761cc20">cif_value_remove_item_by_key</a> (<a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *table, const UChar *key, <a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes an item from a table value, optionally returning the value.  <a href="#ga67366971f91389a49d9b9523e761cc20"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>CIF data values are represented by and to CIF API functions via the opaque data type <code>cif_value_tp</code> . Because this type is truly opaque, <code>cif_value_tp</code> objects cannot directly be declared. Independent value objects must instead be created via function <code><a class="el" href="group__value__funcs.html#ga3fe1a17cd35418767eaefd343f926e0b" title="Allocates and initializes a new value object of the specified kind.">cif_value_create()</a></code>, and <em>independent</em> ones should be released via <code><a class="el" href="group__value__funcs.html#gae023e5c1166c8f457333d776686a8f30" title="Frees the specified value object and all resources associated with it.">cif_value_free()</a></code> when they are no longer needed. Unlike the "handles" on CIF structural components that are used in several other parts of the API, <code>cif_value_tp</code> objects are complete data objects, independent from the backing CIF storage mechanism, albeit sometimes parts of larger aggregate value objects.</p>
<p>CIF permits values' interpretations to be sensitive to whether they are presented whitespace-delimited string form as opposed to being presented in one of the quoted string forms. The CIF API in fact builds in one such distinction in its provision for value kinds <code>CIF_UNK_KIND</code> and <code>CIF_NA_KIND</code> (see below). Technically, that is a matter of convention rather than one of the underlying CIF format or data model, but recognition of the special significance of the values attributed to these kinds is essentially universal.</p>
<p>The API classifies values into several distinct "kinds": character (Unicode string) values, apparently-numeric values, list values, table values, unknown-value place holders, and not-applicable/default-value place holders. These alternatives are represented by the enumeration <code>cif_kind_tp</code>. Value kinds are assigned when values are created, but may be changed by re-initialization. Several functions serve this purpose: <code><a class="el" href="group__value__funcs.html#ga332f27466b5af3f5d829394dbd803047" title="Reinitializes the provided value object to a default value of the specified kind...">cif_value_init()</a></code>, of course, but also <code><a class="el" href="group__value__funcs.html#ga3be5dea8ed4231d7b9ae0859f886e025" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with the...">cif_value_init_char()</a></code>, <code><a class="el" href="group__value__funcs.html#ga8be8921146e46ffe018892db81cbb107" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with a...">cif_value_copy_char()</a></code>, <code><a class="el" href="group__value__funcs.html#ga60c575d2fa5b5f0d83ab4d212e73e1ad" title="Parses the specified Unicode string to produce a floating-point number and its standard...">cif_value_parse_numb()</a></code>, <code><a class="el" href="group__value__funcs.html#ga80b0017214727b7fd841de3b90db8fa2" title="(Re)initializes the given value as a number with the specified value and uncertainty...">cif_value_init_numb()</a></code>, and <code><a class="el" href="group__value__funcs.html#gacd228b9e592c6be981df3cea02176319" title="(Re)initializes the given value as a number with the specified value and uncertainty...">cif_value_autoinit_numb()</a></code>. Additionally, values of character kind and suitable content will be automatically coerced to numeric kind by functions <code><a class="el" href="group__value__funcs.html#ga5d0671fa297a3db716b824dc3fc5396c" title="Returns the value represented by the given number value object.">cif_value_get_number()</a></code> and <code><a class="el" href="group__value__funcs.html#gaf260b314e086bdc6e01650432e3c0c0a" title="Returns the uncertainty of the value represented by the given number value object...">cif_value_get_su()</a></code>, and under some circumstances, values will be coerced between character and n/a or unknown-value kind via function <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>. If it is not known, the kind of a value object can be determined via <code><a class="el" href="group__value__funcs.html#gadc69676873c55ee05aa0b06bf8b16364" title="Returns the kind code of the specified value.">cif_value_kind()</a></code>; this is important, because many of the value manipulation functions are useful only for values of certain kinds.</p>
<p>Values of list and table kind aggregate other value objects. The aggregates do not accept independent value objects directly into themselves; instead they make copies of values entered into them so as to reduce confusion about object ownership. Such internal copies can still be exposed outside their container objects, however, to reduce copying and facilitate value manipulation. Value objects that belong to a list or table aggregate are <em>dependent</em> on their container object, and must not be directly freed.</p>
<p>Table values associate other values with Unicode string keys. Unlike CIF data values and keywords, table keys are not "case insensitive". They do, however, take Unicode canonical equivalence into account, thus Unicode strings containing different sequences of characters and yet canonically equivalent to each other can be used interchangeably as table keys. When keys are enumerated via <code><a class="el" href="group__value__funcs.html#gaaf36b5e373b50c8e1b0c1faf9651cc22" title="Retrieves an array of the keys of a table value.">cif_value_get_keys()</a></code>, the form of the key most recently used to enter a value into the table is the form provided. Table keys may contain whitespace, including leading and trailing whitespace, which is significant. The Unicode string consisting of zero characters is a valid table key. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gacd228b9e592c6be981df3cea02176319"></a><!-- doxytag: member="cif.h::cif_value_autoinit_numb" ref="gacd228b9e592c6be981df3cea02176319" args="(cif_value_tp *numb, double val, double su, unsigned int su_rule)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_autoinit_numb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>numb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>su</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>su_rule</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)initializes the given value as a number with the specified value and uncertainty, automatically choosing the number of significant digits to keep based on the specified <code>su</code> and <code>su_rule</code>. </p>
<p>Any previous contents of the provided value are released, as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code>.</p>
<p>The number's text representation will be formatted with a standard uncertainty if and only if the given su is greater than zero. In that case, the provided su_rule governs the number of decimal digits with which the value text is formatted, and the number of digits of value and su that are recorded. The largest scale is chosen such that the significant digits of the rounded su, interpreted as an integer, are less than or equal to the su_rule. The most commonly used su_rule is probably 19, but others are used as well, including at least 9, 27, 28, 29, and 99. The su_rule must be at least 2, and behavior is undefined if its decimal representation has more significant digits than the implementation-defined maximum decimal precision of a double. If su_rule is less than 6 then some standard uncertainties may be foratted as (0) in the value's text representation.</p>
<p>If the <code>su</code> is exactly zero then all significant digits are recorded to represent the exact value of <code>val</code>. The <code>su_rule</code> is ignored in this case, and no su is included in the text representation.</p>
<p>The value's text representation is expressed in scientific notation if it would otherwise have more than five leading zeroes or any trailing insignificant zeroes. Otherwise, it is expressed in plain decimal notation.</p>
<p>The value is marked as not quoted; provided it has suitable form, it can subsequently be marked quoted via <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>.</p>
<p>Behavior is undefined if <code>val</code> or <code>su</code> has a value that does not correspond to a finite real number (i.e. if one of those values represents an infinite value or does not represent any number at all).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numb</em>&nbsp;</td><td>a pointer to the number value object to initialize</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>the numeric value to assign to the number</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>su</em>&nbsp;</td><td>the absolute numeric standard uncertainty in the specified value; must not be negative</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>su_rule</em>&nbsp;</td><td>governs rounding of the value and uncertainty; it is a "rule" in the sense that the rounding conventions it governs are sometimes referred to by names of form "rule of 19"</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns CIF_OK on success, or an error code (typically <code>CIF_ERROR</code> ) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gac6eb6d7ad6225498e56c89ee225c2c46"></a><!-- doxytag: member="cif.h::cif_value_clean" ref="gac6eb6d7ad6225498e56c89ee225c2c46" args="(cif_value_tp *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cif_value_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees any resources associated with the provided value object without freeing the object itself, changing it into an instance of the explicit unknown value. </p>
<p>This function's primary uses are internal, but it is available for anyone to use. External code more often wants <code><a class="el" href="group__value__funcs.html#gae023e5c1166c8f457333d776686a8f30" title="Frees the specified value object and all resources associated with it.">cif_value_free()</a></code> instead. This function does not directly affect any managed CIF.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a valid pointer to the value object to clean</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success. In principle, an error code such as <code>CIF_ERROR</code> is returned on failure, but no specific failure conditions are currently defined. </dd></dl>

</div>
</div>
<a class="anchor" id="ga19562573b8a23de41705f0c15caefd9a"></a><!-- doxytag: member="cif.h::cif_value_clone" ref="ga19562573b8a23de41705f0c15caefd9a" args="(cif_value_tp *value, cif_value_tp **clone)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>clone</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates an independent copy of a CIF value object. </p>
<p>For composite values (LIST and TABLE), the result is a deep clone -- all members of the original value are themselves cloned, recursively, to create the members of the cloned result. If the referent of the <code>clone</code> parameter is not NULL, then the object it points to is first cleaned up as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code>, then overwritten with the cloned data; otherwise, a new value object is allocated and a pointer to it is written where <code>clone</code> points.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object to clone</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>clone</em>&nbsp;</td><td>the location where a pointer to the cloned value should be made to reside, either by replacing the contents of an existing value object or by recording a pointer to a new one; must not be NULL. If <code>*clone</code> is not NULL then it must point to a valid cif value object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga8be8921146e46ffe018892db81cbb107"></a><!-- doxytag: member="cif.h::cif_value_copy_char" ref="ga8be8921146e46ffe018892db81cbb107" args="(cif_value_tp *value, const UChar *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_copy_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with a copy of the specified text. </p>
<p>This function performs the same job as <code><a class="el" href="group__value__funcs.html#ga3be5dea8ed4231d7b9ae0859f886e025" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with the...">cif_value_init_char()</a></code>, except that it makes a copy of the value text. <b><em>Responsibility for the <code>text</code> argument does not change</em></b>, and the value object does not become sensitive to change via the <code>text</code> pointer. Unlike <code><a class="el" href="group__value__funcs.html#ga3be5dea8ed4231d7b9ae0859f886e025" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with the...">cif_value_init_char()</a></code>, this function is thus suitable for use with initialization text that resides on the stack (e.g. in a local array variable) or in read-only memory.</p>
<p>The value is marked as quoted; provided it has suitable form, it can subsequently be marked unquoted via <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object to be initialized; must not be NULL</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>text</em>&nbsp;</td><td>the new text content for the specified value object; must not be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga3be5dea8ed4231d7b9ae0859f886e025" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with the...">cif_value_init_char()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga3fe1a17cd35418767eaefd343f926e0b"></a><!-- doxytag: member="cif.h::cif_value_create" ref="ga3fe1a17cd35418767eaefd343f926e0b" args="(cif_kind_tp kind, cif_value_tp **value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and initializes a new value object of the specified kind. </p>
<p>The new object is initialized with a kind-dependent default value: </p>
<ul>
<li>an empty string for <code>CIF_CHAR_KIND</code> </li>
<li>an exact zero for <code>CIF_NUMB_KIND</code> </li>
<li>an empty list or table for <code>CIF_LIST_KIND</code> or <code>CIF_TABLE_KIND</code>, respectively </li>
<li>(there is only one possible distinct value each for <code>CIF_UNK_KIND</code> and <code>CIF_NA_KIND</code>)</li>
</ul>
<p>For <code>CIF_CHAR_KIND</code> and <code>CIF_NUMB_KIND</code>, however, it is somewhat more efficient to create a value object of kind <code>CIF_UNK_KIND</code> and then initialize it with the appropriate kind-specific function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kind</em>&nbsp;</td><td>the value kind to create</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>the location where a pointer to the new value should be recorded; must not be NULL. The initial value of <code>*value</code> is ignored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success or an error code (typically <code>CIF_ERROR</code> ) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="gae023e5c1166c8f457333d776686a8f30"></a><!-- doxytag: member="cif.h::cif_value_free" ref="gae023e5c1166c8f457333d776686a8f30" args="(cif_value_tp *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cif_value_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Frees the specified value object and all resources associated with it. </p>
<p>This provides only resource management; it has no effect on any managed CIF. This function is a safe no-op when its argument is NULL.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a valid pointer to the value object to free, or NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5a832500e93ac0a60365b9b314fd26c4"></a><!-- doxytag: member="cif.h::cif_value_get_element_at" ref="ga5a832500e93ac0a60365b9b314fd26c4" args="(cif_value_tp *value, size_t index, cif_value_tp **element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>element</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an element of a list value by its index. </p>
<p><em>A pointer to the actual value object contained in the list is returned, so modifications to the value will be reflected in the list.</em> If that is not desired then the caller can make a copy via <code><a class="el" href="group__value__funcs.html#ga19562573b8a23de41705f0c15caefd9a" title="Creates an independent copy of a CIF value object.">cif_value_clone()</a></code> . The caller must not free the returned value, but may modify it in any other way.</p>
<p>It is unsafe for the caller to retain the provided element pointer if and when the list that owns the element ceases to be under its exclusive control, for the lifetime of the referenced value object is then uncertain. It will not outlive the list that owns it, but various operations on the list may cause it to be discarded while the list is still live. Note in particular that a context switch to another thread that has access to the list object constitutes passing out of the caller's control. If multiple threads have unsynchronized concurrent access to the list then no element retrieved from it via this function is <em>ever</em> safe to use, not even to clone it.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the <code>CIF_LIST_KIND</code> value from which to retrieve an element</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>the zero-based index of the requested element; must be less than the number of elements in the list</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>element</em>&nbsp;</td><td>the location where a pointer to the requested value should be written; must not be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_LIST_KIND</code>; otherwise returns <code>CIF_OK</code> if <code>index</code> is less than the number of elements in the list, else <code>CIF_INVALID_INDEX</code> . </dd></dl>

</div>
</div>
<a class="anchor" id="gadceedc42c126d2634f68a85e4881753e"></a><!-- doxytag: member="cif.h::cif_value_get_element_count" ref="gadceedc42c126d2634f68a85e4881753e" args="(cif_value_tp *value, size_t *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_element_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Determines the number of elements of a composite data value. </p>
<p>Composite values are those having kind <code>CIF_LIST_KIND</code> or <code>CIF_TABLE_KIND</code> . For the purposes of this function, the "elements" of a table are its key/value <em>pairs</em> . Only the direct elements of a list or table are counted, not the elements of any lists or tables nested within.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object whose elements are to be counted; must not be NULL</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>a pointer to a location where the number of elements should be recorded</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd><code>CIF_OK</code> if the value has kind <code>CIF_LIST_KIND</code> or <code>CIF_TABLE_KIND</code>, otherwise <code>CIF_ARGUMENT_ERROR</code> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf58f82f1280c46bc214f07f2a16ecf9e"></a><!-- doxytag: member="cif.h::cif_value_get_item_by_key" ref="gaf58f82f1280c46bc214f07f2a16ecf9e" args="(cif_value_tp *table, const UChar *key, cif_value_tp **value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_item_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Looks up a table entry by key and optionally returns the associated value. </p>
<p>If the key is present in the table and the <code>value</code> argument is non-NULL, then a pointer to the value associated with the key is written where <code>value</code> points. Otherwise, this function simply indicates via its return value whether the specified key is present in the table. <em>Any value object provided via the <code>value</code> parameter continues to be owned by the table.</em> It must not be freed, and any modifications to it will be reflected in the table. If that is not desired then the caller can make a copy of the value via <code><a class="el" href="group__value__funcs.html#ga19562573b8a23de41705f0c15caefd9a" title="Creates an independent copy of a CIF value object.">cif_value_clone()</a></code> .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>a pointer to the table value in which to look up the specified key</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>the key to look up, as a NUL-terminated Unicode string.</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>if not NULL, the location where a pointer to the discovered value, if any, should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_TABLE_KIND</code> , otherwise </li>
<li><code>CIF_OK</code> if the key was found in the table or </li>
<li><code>CIF_NOSUCH_ITEM</code> if the key was not found. </li>
<li>in principle, an error code such as <code>CIF_ERROR</code> is returned in the event of a failure other than those already described, but no such failure conditions are currently defined.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga5a832500e93ac0a60365b9b314fd26c4" title="Retrieves an element of a list value by its index.">cif_value_get_element_at()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaaf36b5e373b50c8e1b0c1faf9651cc22"></a><!-- doxytag: member="cif.h::cif_value_get_keys" ref="gaaf36b5e373b50c8e1b0c1faf9651cc22" args="(cif_value_tp *table, const UChar ***keys)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_keys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar ***&nbsp;</td>
          <td class="paramname"> <em>keys</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves an array of the keys of a table value. </p>
<p>Although tables are insensitive to differences between canonically equivalent keys, this function always provides keys in the form most recently entered into the table.</p>
<p>The caller assumes responsibility for freeing the returned array itself, but not the keys in it. <b><em>The keys remain the responsibility of the table, and MUST NOT be freed or modified in any way.</em></b> Each key is a NUL-terminated Unicode string, and the end of the list is marked by a NULL element.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>a pointer to the table value whose keys are requested</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>keys</em>&nbsp;</td><td>the location where a pointer to the array of keys should be written; must not be NULL.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>table</code> has kind different from <code>CIF_TABLE_KIND</code> , otherwise </li>
<li><code>CIF_OK</code> if the keys were successfully retrieved, or </li>
<li>an error code, typically <code>CIF_ERROR</code> , if retrieving the keys fails for reasons other than those already described </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga5d0671fa297a3db716b824dc3fc5396c"></a><!-- doxytag: member="cif.h::cif_value_get_number" ref="ga5d0671fa297a3db716b824dc3fc5396c" args="(cif_value_tp *numb, double *val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>numb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the value represented by the given number value object. </p>
<p>If the provided value is of character kind then first an attempt is made to convert it to numeric kind, as if by parsing its text value via <code><a class="el" href="group__value__funcs.html#ga60c575d2fa5b5f0d83ab4d212e73e1ad" title="Parses the specified Unicode string to produce a floating-point number and its standard...">cif_value_parse_numb()</a></code>. If the value is not initially of numeric kind, then this function's success depends on such a conversion.</p>
<p>Behavior is implementation-defined if the represented numeric value is outside the representable range of type <code>double</code> . Some of the possible behaviors include raising a floating-point trap and returning a special value, such as an IEEE infinity.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numb</em>&nbsp;</td><td>a pointer the the value object whose numeric value is requested </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>a pointer to the location where the numeric value should be recorded; must be a valid pointer to suitably-aligned storage large enough to accommodate a <code>double</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, <code>CIF_INVALID_NUMBER</code> if the provided object is of character kind and cannot be parsed as a number, <code>CIF_ARGUMENT_ERROR</code> if the provided object is othewise not of numeric kind, or another code, typically <code>CIF_ERROR</code>, if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf260b314e086bdc6e01650432e3c0c0a"></a><!-- doxytag: member="cif.h::cif_value_get_su" ref="gaf260b314e086bdc6e01650432e3c0c0a" args="(cif_value_tp *numb, double *su)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_su </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>numb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>su</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the uncertainty of the value represented by the given number value object. </p>
<p>If the provided value is of character kind then first an attempt is made to convert it to numeric kind, as if by parsing its text value via <code><a class="el" href="group__value__funcs.html#ga60c575d2fa5b5f0d83ab4d212e73e1ad" title="Parses the specified Unicode string to produce a floating-point number and its standard...">cif_value_parse_numb()</a></code>. If the value is not initially of numeric kind, then this function's success depends on such a conversion.</p>
<p>The uncertainty is zero for an exact number. Behavior is implementation-defined if the uncertainty is outside the representable range of type <code>double</code> .</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numb</em>&nbsp;</td><td>a pointer the the value object whose numeric standard uncertainty is requested </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>su</em>&nbsp;</td><td>a pointer to the location where the uncertainty should be recorded; must be a valid pointer to suitably aligned storage large enough to accommodate a <code>double</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, <code>CIF_INVALID_NUMBER</code> if the provided object is of character kind and cannot be parsed as a number, <code>CIF_ARGUMENT_ERROR</code> if the provided object is othewise not of numeric kind, or another code, typically <code>CIF_ERROR</code>, if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e6ce5f64d8099ad2cbcfe6453d1b492"></a><!-- doxytag: member="cif.h::cif_value_get_text" ref="ga7e6ce5f64d8099ad2cbcfe6453d1b492" args="(cif_value_tp *value, UChar **text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_get_text </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar **&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieves the text representation of the specified value. </p>
<p>It is important to understand that the "text representation" provided by this function is not the same as the CIF format representation in which the same value might be serialized to a CIF file. Instead, it is the <em>parsed</em> text representation, so, among other things, it omits any CIF delimiters and might not adhere to CIF line length limits.</p>
<p>The value text, if any, obtained via this function belongs to then caller.</p>
<p>This function is natural for values of kind <code>CIF_CHAR_KIND</code>. It is also fairly natural for values of kind <code>CIF_NUMB_KIND</code>, as those carry a text representation with them to allow for undelimited number-like values that are intended to be interpreted as text. It is natural, but trivial, for kinds <code>CIF_NA_KIND</code> and <code>CIF_UNK_KIND</code>, for which the text representation is NULL (as opposed to empty). It is decidedly unnatural, however, for the composite value kinds <code>CIF_LIST_KIND</code> and <code>CIF_TABLE_KIND</code>. As such, the text for values of those kinds is also NULL, though that is subject to change in the future.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object whose text is requested</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>text</em>&nbsp;</td><td>the location where a pointer to copy of the value text (or NULL, as appropriate) should be recorded; must not be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or <code>CIF_ERROR</code> on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga332f27466b5af3f5d829394dbd803047"></a><!-- doxytag: member="cif.h::cif_value_init" ref="ga332f27466b5af3f5d829394dbd803047" args="(cif_value_tp *value, cif_kind_tp kind)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a>&nbsp;</td>
          <td class="paramname"> <em>kind</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reinitializes the provided value object to a default value of the specified kind. </p>
<p>The value referenced by the provided handle should have been allocated via <code><a class="el" href="group__value__funcs.html#ga3fe1a17cd35418767eaefd343f926e0b" title="Allocates and initializes a new value object of the specified kind.">cif_value_create()</a></code>. Any unneeded resources it holds are released. The specified value kind does not need to be the same as the value's present kind. Kind-specific default values are documented as with <code><a class="el" href="group__value__funcs.html#ga3fe1a17cd35418767eaefd343f926e0b" title="Allocates and initializes a new value object of the specified kind.">cif_value_create()</a></code>.</p>
<p>This function is equivalent to <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code> when the specified kind is <code>CIF_UNK_KIND</code>, and it is less useful than the character- and number-specific (re)initialization functions. It is the only means available to change an existing general value in-place to a list, table, or N/A value, however, and it can be used to efficently empty a list or table value.</p>
<p>On failure, the value is left in a valid but otherwise unspecified state.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a handle on the value to reinitialize; must not be <code>NULL</code> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>kind</em>&nbsp;</td><td>the cif value kind as which the value should be reinitialized</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ga3be5dea8ed4231d7b9ae0859f886e025"></a><!-- doxytag: member="cif.h::cif_value_init_char" ref="ga3be5dea8ed4231d7b9ae0859f886e025" args="(cif_value_tp *value, UChar *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_init_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)initializes the specified value object as being of kind <code>CIF_CHAR_KIND</code>, with the specified text </p>
<p>Any previous contents of the provided value object are first cleaned as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code>. <b><em>Responsibility for the provided string passes to the value object</em></b>; it should not subsequently be managed directly by the caller. This implies that the text must be dynamically allocated. The value object will become sensitive to text changes performed afterward via the <code>text</code> pointer. This behavior could be described as wrapping an existing Unicode string in a CIF value object.</p>
<p>The value is marked as quoted; provided it has suitable form, it can subsequently be marked unquoted via <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object to be initialized; must not be NULL</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>text</em>&nbsp;</td><td>the new text content for the specified value object; must not be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or an error code (typically <code>CIF_ERROR</code> ) on failure</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga8be8921146e46ffe018892db81cbb107" title="(Re)initializes the specified value object as being of kind CIF_CHAR_KIND, with a...">cif_value_copy_char()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga80b0017214727b7fd841de3b90db8fa2"></a><!-- doxytag: member="cif.h::cif_value_init_numb" ref="ga80b0017214727b7fd841de3b90db8fa2" args="(cif_value_tp *numb, double val, double su, int scale, int max_leading_zeroes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_init_numb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>numb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>su</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>max_leading_zeroes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>(Re)initializes the given value as a number with the specified value and uncertainty, with a number of significant figures determined by the specified <code>scale</code> </p>
<p>Any previous contents of the provided value are released, as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code> .</p>
<p>The value's text representation will be formatted with a standard uncertainty if and only if the given standard uncertainty (<code>su</code> ) is greater than zero. It is an error for the uncertainty to be less than zero, but it may be exactly equal to zero.</p>
<p>The <code>scale</code> gives the number of significant digits to the right of the units digit; the value and uncertainty will be rounded or extended to this number of decimal places as needed. Any rounding is performed according to the floating-point rounding mode in effect at that time. The scale may be less than zero, indicating that the units digit and possibly some of the digits to its left are insignificant and not to be recorded. If the given su rounds to exactly zero at the specified scale, then the resulting number object represents an exact number, whether the su given was itself exactly zero or not.</p>
<p>If the scale is less than zero or if pure decimal notation would require more than <code>max_leading_zeroes</code> leading zeroes after the decimal point, then the number's text representation is formatted in scientific notation (d.ddde+-dd; the number of digits of mantissa and exponent may vary). Otherwise, it is formatted in decimal notation.</p>
<p>It is an error if a text representation consistent with the arguments would require more characters than the CIF 2.0 maximum line length (2048 characters).</p>
<p>The value is marked as not quoted; provided it has suitable form, it can subsequently be marked quoted via <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>.</p>
<p>The behavior of this function is constrained by the characteristics of the data type (<code>double</code> ) of the <code>value</code> and <code>su</code> parameters. Behavior is undefined if a scale is specified that exceeds the maximum possible precision of a value of type double, or such that <code>10^</code>(-scale) is greater than the greatest representable finite double. Behavior is undefined if <code>val</code> or <code>su</code> has a value that does not correspond to a finite real number (i.e. if one of those values represents an infinite value or does not represent any number at all).</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numb</em>&nbsp;</td><td>a pointer to the value object to initialize</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>the numeric value to assign to the number</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>su</em>&nbsp;</td><td>the absolute numeric standard uncertainty in the specified value</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scale</em>&nbsp;</td><td>the number of significant digits to the right of the decimal point in both <code>val</code> and <code>su</code> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>max_leading_zeroes</em>&nbsp;</td><td>the maximimum number of leading zeroes with which the text representation of numbers having absolute value less than 1 will be formatted; must not be less than zero.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns CIF_OK on success, or an error code (typically <code>CIF_ERROR</code> ) on failure. </dd></dl>

</div>
</div>
<a class="anchor" id="gafe734d235d79b15ec1ca88fb0f7f194a"></a><!-- doxytag: member="cif.h::cif_value_insert_element_at" ref="gafe734d235d79b15ec1ca88fb0f7f194a" args="(cif_value_tp *value, size_t index, cif_value_tp *element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_insert_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>element</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an element into the specified list value at the specified position, pushing back the elements (if any) initially at that and following positions. </p>
<p>The provided value is <em>copied</em> into the list (if not NULL); responsibility for the original object is not transferred. The list may be extended by inserting at the index one past its last element.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the list value to modify</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>the zero-based index of the element to replace; must be less than or equal to the number of elements in the list</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>element</em>&nbsp;</td><td>a pointer to the value to insert, or NULL to insert a <code>CIF_UNK_KIND</code> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_LIST_KIND</code> , otherwise </li>
<li><code>CIF_INVALID_INDEX</code> if the index is greater than the initial number of list elements, or </li>
<li><code>CIF_OK</code> if a value was successfully inserted, or </li>
<li>an error code, typically <code>CIF_ERROR</code> , if inserting the value fails for reasons other than those already described</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga890298d11a6153e47bd22a306c7b71af" title="Replaces an existing element of a list value with a different value.">cif_value_set_element_at()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga91436bec5f43ed8627871d5eea6192a6"></a><!-- doxytag: member="cif.h::cif_value_is_quoted" ref="ga91436bec5f43ed8627871d5eea6192a6" args="(cif_value_tp *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#gab312e9783ea613a434d4ef928a1513a1">cif_quoted_tp</a> cif_value_is_quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns whether the value should be interpreted as if it were presented quoted. </p>
<p>Unlike most CIF functions, the return value is not an error code, as no error conditions are defined for or detectable by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object whose quoting status is requested; must point at an initialized value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the quoting code of the specified value </dd></dl>

</div>
</div>
<a class="anchor" id="gadc69676873c55ee05aa0b06bf8b16364"></a><!-- doxytag: member="cif.h::cif_value_kind" ref="gadc69676873c55ee05aa0b06bf8b16364" args="(cif_value_tp *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__datatypes.html#ga924f12fdd599ac5cbf18edc69ccd9e86">cif_kind_tp</a> cif_value_kind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the kind code of the specified value. </p>
<p>Unlike most CIF functions, the return value is not an error code, as no error conditions are defined for or detectable by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object whose kind is requested; must point at an initialized value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the kind code of the specified value </dd></dl>

</div>
</div>
<a class="anchor" id="ga60c575d2fa5b5f0d83ab4d212e73e1ad"></a><!-- doxytag: member="cif.h::cif_value_parse_numb" ref="ga60c575d2fa5b5f0d83ab4d212e73e1ad" args="(cif_value_tp *numb, UChar *text)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_parse_numb </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>numb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UChar *&nbsp;</td>
          <td class="paramname"> <em>text</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parses the specified Unicode string to produce a floating-point number and its standard uncertainty, recording them in the provided value object. </p>
<p>For success, the entire input string must be successfully parsed. On success (only), any previous contents of the value object are released as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code> ; otherwise, the value object is not modified. <b><em>The value object takes ownership of the parsed text on success.</em></b> The caller is responsible for ensuring that the <code>text</code> pointer is not afterward used to modify its referrent. The representable values that can be initialized in this manner are not limited to those representable the machine's native floating-point format.</p>
<p>This behavior could be described as wrapping an existing Unicode string in a (numeric) CIF value object.</p>
<p>The value is marked as not quoted; provided it has suitable form, it can subsequently be marked quoted via <code><a class="el" href="group__value__funcs.html#gafa57153e1fc82f0891c354bff3b42a6c" title="Sets whether the value should be interpreted as if it were presented quoted.">cif_value_set_quoted()</a></code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numb</em>&nbsp;</td><td>the value object into which to parse the text</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>text</em>&nbsp;</td><td>the text to parse as a NUL-terminated Unicode string, in one of the forms documented forms documented for numbers in CIF text</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns <code>CIF_OK</code> on success, or else an error code characterizing the nature of the failure, normally one of: <ul>
<li><code>CIF_INVALID_NUMBER</code> if the text cannot be fully parsed as a number </li>
<li><code>CIF_ERROR</code> in most other cases </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="gae15adcee11ef627922f04786ff00c43f"></a><!-- doxytag: member="cif.h::cif_value_remove_element_at" ref="gae15adcee11ef627922f04786ff00c43f" args="(cif_value_tp *value, size_t index, cif_value_tp **element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_remove_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>element</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an existing element from a list value, optionally returning it to the caller. </p>
<p>Any elements following the removed one in the list are moved forward to fill the gap. The removed element is returned via the <code>element</code> parameter if that parameter is not NULL; in that case the caller assumes responsibility for freeing that value when it is no longer needed. Otherwise, the value is freed by this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>the list value to modify</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>the zero-based index of the element to remove; must be less than the initial number of elements in the list</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>element</em>&nbsp;</td><td>if not NULL, then a pointer to the removed element is written at this location</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_LIST_KIND</code> , otherwise </li>
<li><code>CIF_INVALID_INDEX</code> if the index is greater than the initial number of list elements, else </li>
<li><code>CIF_OK</code> if a value was successfully inserted </li>
<li>in principle, a general error code such as <code>CIF_ERROR</code> may be returned if removing the value fails for reasons other than those already described, but no such failure conditions are currently defined</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga67366971f91389a49d9b9523e761cc20" title="Removes an item from a table value, optionally returning the value.">cif_value_remove_item_by_key()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga67366971f91389a49d9b9523e761cc20"></a><!-- doxytag: member="cif.h::cif_value_remove_item_by_key" ref="ga67366971f91389a49d9b9523e761cc20" args="(cif_value_tp *table, const UChar *key, cif_value_tp **value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_remove_item_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> **&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an item from a table value, optionally returning the value. </p>
<p>If the key is present in the table and the <code>value</code> parameter is non-NULL, then a pointer to the value associated with the key is written where <code>value</code> points, and the caller assumes responsibility for freeing the value when it is no longer needed. Otherwise, this function automatically frees the value object, if any, of the removed entry.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>a pointer to the table value to modify</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the entry to remove, as a NUL-terminated Unicode string</td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>if not NULL, the location where a pointer to the removed value, if any, should be written</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_TABLE_KIND</code> , otherwise </li>
<li><code>CIF_OK</code> if the key was found in the table (and the entry removed) or </li>
<li><code>CIF_NOSUCH_ITEM</code> if the key was not found. </li>
<li>in principle, an error code such as <code>CIF_ERROR</code> is returned in the event of a failure other than those already described, but no such failure conditions are currently defined.</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#gae15adcee11ef627922f04786ff00c43f" title="Removes an existing element from a list value, optionally returning it to the caller...">cif_value_remove_element_at()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga890298d11a6153e47bd22a306c7b71af"></a><!-- doxytag: member="cif.h::cif_value_set_element_at" ref="ga890298d11a6153e47bd22a306c7b71af" args="(cif_value_tp *value, size_t index, cif_value_tp *element)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_set_element_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>element</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Replaces an existing element of a list value with a different value. </p>
<p>The provided value is <em>copied</em> into the list (if not NULL); responsibility for the original object is not transferred. The replaced value is first cleaned as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code>, then the new value is copied onto it. That will be visible to code that holds a reference to the value (obtained via <code><a class="el" href="group__value__funcs.html#ga5a832500e93ac0a60365b9b314fd26c4" title="Retrieves an element of a list value by its index.">cif_value_get_element_at()</a></code>).</p>
<p>Special case: if the replacement value is the same object as the one currently at the specified position in the list, then this function succeeds without changing anything.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the <code>CIF_LIST_KIND</code> value to modify</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>the zero-based index of the element to replace; must be less than the number of elements in the list</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>element</em>&nbsp;</td><td>a pointer to the replacement value, or <code>NULL</code> to set a <code>CIF_UNK_KIND</code> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>value</code> has kind different from <code>CIF_LIST_KIND</code> , otherwise </li>
<li><code>CIF_INVALID_INDEX</code> if the index is greater than or equal to the number of list elements, or </li>
<li><code>CIF_OK</code> if a value was successfully set, or </li>
<li>an error code, typically <code>CIF_ERROR</code> , if setting the value fails for reasons other than those already described</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#gafe734d235d79b15ec1ca88fb0f7f194a" title="Inserts an element into the specified list value at the specified position, pushing...">cif_value_insert_element_at()</a> </dd>
<dd>
<a class="el" href="group__value__funcs.html#gaced5bb916c9734b4d0799e131cbd3221" title="Associates a specified value and key in the provided table value.">cif_value_set_item_by_key()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaced5bb916c9734b4d0799e131cbd3221"></a><!-- doxytag: member="cif.h::cif_value_set_item_by_key" ref="gaced5bb916c9734b4d0799e131cbd3221" args="(cif_value_tp *table, const UChar *key, cif_value_tp *item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_set_item_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UChar *&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>item</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associates a specified value and key in the provided table value. </p>
<p>The value and key are copied into the table; responsibility for the originals does not transfer. If a value was already associated with the given key then it is first cleaned as if by <code><a class="el" href="group__value__funcs.html#gac6eb6d7ad6225498e56c89ee225c2c46" title="Frees any resources associated with the provided value object without freeing the...">cif_value_clean()</a></code>, then the new value is copied onto it. That will be visible to code that holds a reference to the value (obtained via <code><a class="el" href="group__value__funcs.html#gaf58f82f1280c46bc214f07f2a16ecf9e" title="Looks up a table entry by key and optionally returns the associated value.">cif_value_get_item_by_key()</a></code>).</p>
<p>Special case: if the item value is the same object as one currently associated with the given key in the table, then this function succeeds without changing anything.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>table</em>&nbsp;</td><td>a pointer to the table value to modify</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>key</em>&nbsp;</td><td>the key of the table entry to set or modify, as a NUL-terminated Unicode string; must meet CIF validity criteria</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>item</em>&nbsp;</td><td>a pointer to the value object to enter into the table, or <code>NULL</code> to enter a <code>CIF_UNK_KIND</code> value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns a status code characteristic of the result: <ul>
<li><code>CIF_ARGUMENT_ERROR</code> if the <code>table</code> has kind different from <code>CIF_TABLE_KIND</code> , otherwise </li>
<li><code>CIF_INVALID_INDEX</code> if the given key does not meet CIF validity criteria </li>
<li><code>CIF_OK</code> if the entry was successfully set / updated, or </li>
<li>an error code, typically <code>CIF_ERROR</code> , if setting or updating the entry fails for reasons other than those already described</li>
</ul>
</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__value__funcs.html#ga890298d11a6153e47bd22a306c7b71af" title="Replaces an existing element of a list value with a different value.">cif_value_set_element_at()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa57153e1fc82f0891c354bff3b42a6c"></a><!-- doxytag: member="cif.h::cif_value_set_quoted" ref="gafa57153e1fc82f0891c354bff3b42a6c" args="(cif_value_tp *value, cif_quoted_tp quoted)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cif_value_set_quoted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gaf5c256b25e639154880eea5cb183b080">cif_value_tp</a> *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__datatypes.html#gab312e9783ea613a434d4ef928a1513a1">cif_quoted_tp</a>&nbsp;</td>
          <td class="paramname"> <em>quoted</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets whether the value should be interpreted as if it were presented quoted. </p>
<p>This function may coerce values in-place between kind <code>CIF_CHAR_KIND</code> and either <code>CIF_UNK_KIND</code> or <code>CIF_NA_KIND</code>. It must must not be called with <code>QUOTED</code> as its second argument when the first has kind <code>CIF_LIST_KIND</code> or <code>CIF_TABLE_KIND</code>.</p>
<p>Values of character kind representing reserved strings (see <code><a class="el" href="group__utility__funcs.html#gafdec982eabc2045855c4b4be3a785e82" title="Determines whether a given string takes a reserved form that must not be presented...">cif_is_reserved_string()</a></code>) cannot be set unquoted. Values of list or table kind cannot be set quoted, regardless of their contents. If this function is asked to perform such an action then it will instead return <code>CIF_ARGUMENT_ERROR</code>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>a pointer to the value object whose quoting status is requested; must point at an initialized value</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>quoted</em>&nbsp;</td><td>the quoting status to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns CIF_OK on success, or an error code (typically <code>CIF_ARGUMENT_ERROR</code> or <code>CIF_ERROR</code> ) on failure. </dd></dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

