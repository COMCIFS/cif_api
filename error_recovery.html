<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: Parse error recovery</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="error_recovery">Parse error recovery </a></h1><p>Since the built-in parser allows syntax and grammar errors to be ignored, it must provide a mechanism for recovering from such errors to continue the parse. In general, there is no single, clear approach for recovering from any given error, so the following table documents the approach taken by the parser in each case. </p>
<table border="1" cellspacing="3" cellpadding="3">
<tr>
<th><p>Condition</p>
</th><th><p>Code</p>
</th><th><p>Recovery action </p>
</th></tr>
<tr>
<td><p>Wrong character encoding</p>
</td><td><p><code>CIF_WRONG_ENCODING</code> </p>
</td><td><p>ignore the problem </p>
</td></tr>
<tr>
<td colspan="3"><p>CIF 2.0 must consist of Unicode character data encoded in UTF-8, and this error is emitted if the input is recognized to be encoded differently. That this error is emitted at all generally means that the parser has identified the signature of a different (known) encoding, so it can recover by reading the data according to the detected encoding, even though such input does not comply with the CIF 2.0 specifications. </p>
</td></tr>
<tr>
<td><p>Disallowed input character</p>
</td><td><p><code>CIF_DISALLOWED_CHAR</code> </p>
</td><td><p>substitute a replacement character </p>
</td></tr>
<tr>
<td colspan="3"><p>This error indicates that an input character outside the allowed set was read. The parser can recover by accepting the character. Which characters are allowed depends on which version of CIF is being parsed. </p>
</td></tr>
<tr>
<td><p>Missing whitespace</p>
</td><td><p><code>CIF_MISSING_SPACE</code> </p>
</td><td><p>assume the omitted whitespace </p>
</td></tr>
<tr>
<td colspan="3"><p>Whitespace separation is required between most CIF grammatic units. In some cases, the omission of such whitespace can be recognized by the parser, resulting in this error. In particular, this is the error that will be reported when a CIF1-style string with embedded delimiter is encountered when parsing in CIF 2 mode. If the opening delimiter of a table is omitted then this error will occur at trailing colon of each table key. </p>
</td></tr>
<tr>
<td><p>Invalid block code</p>
</td><td><p><code>CIF_INVALID_BLOCKCODE</code> </p>
</td><td><p>use the block code anyway </p>
</td></tr>
<tr>
<td colspan="3"><p>Although the API's CIF manipulation functions will not allow blocks with invalid codes to be created directly by client programs, the parser can and will create such blocks to accommodate inputs that use such codes. The result is not a valid instance of the CIF data model. </p>
</td></tr>
<tr>
<td><p>Duplicate block code</p>
</td><td><p><code>CIF_DUP_BLOCKCODE</code> </p>
</td><td><p>reopen the specified block </p>
</td></tr>
<tr>
<td colspan="3"><p>Block codes must be unique within a given CIF. To handle a duplicate block code, the parser reopens the specified block and parses the following contents into it. This may well lead to additional errors being reported. </p>
</td></tr>
<tr>
<td><p>Missing block header</p>
</td><td><p><code>CIF_NO_BLOCK_HEADER</code> </p>
</td><td><p>parse into an anonymous block </p>
</td></tr>
<tr>
<td colspan="3"><p>To handle data that appear prior to any block header, the parser creates a data block with an empty name and parses into that. The data are available via that name, but the result is not a valid instance of the CIF data model. </p>
</td></tr>
<tr>
<td><p>Invalid frame code</p>
</td><td><p><code>CIF_INVALID_FRAMECODE</code> </p>
</td><td><p>use the frame code anyway </p>
</td></tr>
<tr>
<td colspan="3"><p>Although the API's CIF manipulation functions will not allow save frames with invalid codes to be created directly by client programs, the parser can and will create such frames to accommodate inputs that use such codes. The result is not a valid instance of the CIF data model. </p>
</td></tr>
<tr>
<td><p>Duplicate frame code</p>
</td><td><p><code>CIF_DUP_FRAMECODE</code> </p>
</td><td><p>reopen the specified frame </p>
</td></tr>
<tr>
<td colspan="3"><p>Save frame codes must be unique within a their containing block or save frame. To handle a duplicate frame code, the parser reopens the specified frame and parses the following contents into it. This may well lead to additional errors being reported. </p>
</td></tr>
<tr>
<td><p>Disallowed save frame</p>
</td><td><p><code>CIF_FRAME_NOT_ALLOWED</code> </p>
</td><td><p>accept the save frame </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when a save frame header is encountered while parsing with save frame support completely disabled. The parser recovers by parsing the frame as if save frame support were enabled at the default level. </p>
</td></tr>
<tr>
<td><p>Unterminated save frame</p>
</td><td><p><code>CIF_NO_FRAME_TERM</code> </p>
</td><td><p>assume the missing terminator </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when a data block header is encountered while parsing a save frame, or when a save frame header is encountered while parsing a save frame with nested frames disabled (the default). The parser recovers by assuming the missing save frame terminator at the position where the error is detected. </p>
</td></tr>
<tr>
<td><p>Unterminated save frame at end-of-file</p>
</td><td><p><code>CIF_EOF_IN_FRAME</code> </p>
</td><td><p>assume the missing terminator </p>
</td></tr>
<tr>
<td colspan="3"><p>This is basically the same as the CIF_NO_FRAME_TERM case, but triggered when the end of input occurs while parsing a save frame. This case is distinguished in part because it may indicate a truncated input. </p>
</td></tr>
<tr>
<td><p>Unexpected save frame terminator</p>
</td><td><p><code>CIF_UNEXPECTED_TERM</code> </p>
</td><td><p>ignore </p>
</td></tr>
<tr>
<td colspan="3"><p>If a save frame terminator is encountered outside the scope of a save frame, the parser recovers by ignoring it. This condition cannot be distinguished from the alternative that a save frame header is given without any frame code. </p>
</td></tr>
<tr>
<td><p>Duplicate data name</p>
</td><td><p><code>CIF_DUP_ITEMNAME</code> </p>
</td><td><p>parse and drop the item </p>
</td></tr>
<tr>
<td colspan="3"><p>If a duplicate item name is encountered then it and its associated value(s) are dropped, including when the duplicate appears in a loop. </p>
</td></tr>
<tr>
<td><p>Unexpected value</p>
</td><td><p><code>CIF_UNEXPECTED_VALUE</code> </p>
</td><td><p>ignore the value </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when a value appears outside a list or loop without being paired with a dataname or (in a table) a key. </p>
</td></tr>
<tr>
<td><p>Unexpected (closing) delimiter</p>
</td><td><p><code>CIF_UNEXPECTED_DELIM</code> </p>
</td><td><p>ignore the delimiter </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when a list or table closing delimiter appears without matching opening delimiter preceding it. This can happen when such a delimiter appears in the middle of a whitespace-delimited data value. </p>
</td></tr>
<tr>
<td><p>Missing data value</p>
</td><td><p><code>CIF_MISSING_VALUE</code> </p>
</td><td><p>use a synthetic unknown value </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when a data name or table key appears without a paired value. The parser recovers by synthesizing unknown-value placeholder value. </p>
</td></tr>
<tr>
<td><p>Empty loop header</p>
</td><td><p><code>CIF_NULL_LOOP</code> </p>
</td><td><p>ignore </p>
</td></tr>
<tr>
<td colspan="3"><p>This occurs when the <code>loop_</code> keyword appears without at least one subsequent data name. The parser recovers by ignoring it. </p>
</td></tr>
<tr>
<td><p>Truncated loop packet</p>
</td><td><p><code>CIF_PARTIAL_PACKET</code> </p>
</td><td><p>fill out the packet with unknown values </p>
</td></tr>
<tr>
<td colspan="3"><p>This error occurs when the number of data values in a loop is not an integral multiple of the number of data names. In such cases, the parser can recover by filling in the missing values with out with unknown-value placeholder values. </p>
</td></tr>
<tr>
<td><p>Empty loop</p>
</td><td><p><code>CIF_EMPTY_LOOP</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>This occurs when a valid loop header is not followed by any values. The parser recovers by accepting the empty loop, which can be accommodated by the API's internal CIF representation. The result is not a valid instance of the CIF data model, however. </p>
</td></tr>
<tr>
<td><p>Unterminated list or table</p>
</td><td><p><code>CIF_MISSING_DELIM</code> </p>
</td><td><p>assume the missing delimiter </p>
</td></tr>
<tr>
<td colspan="3"><p>If the closing delimiter of a list or table is omitted, then the parser recovers by assuming the terminator to appear at the point where its absence is recognized. </p>
</td></tr>
<tr>
<td><p>Missing table key</p>
</td><td><p><code>CIF_MISSING_KEY</code> </p>
</td><td><p>drop the value </p>
</td></tr>
<tr>
<td colspan="3"><p>If a value appears inside a table without an associated key, then the parser recovers by dropping it. </p>
</td></tr>
<tr>
<td><p>Missing table key</p>
</td><td><p><code>CIF_NULL_KEY</code> </p>
</td><td><p>use a NULL key </p>
</td></tr>
<tr>
<td colspan="3"><p>If a table entry contains a (colon, value) without any key representation at all (not even an empty string), then the parser can recover by using a NULL key. The result is not a valid instance of the CIF data model. </p>
</td></tr>
<tr>
<td><p>Unquoted table key</p>
</td><td><p><code>CIF_UNQUOTED_KEY</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>This case is distinguished from the <code>CIF_MISSING_KEY</code> case by the presence of a colon in the unquoted value. The key is taken as everything up to the first colon, and the value as everything after </p>
</td></tr>
<tr>
<td><p>Text block as a table key</p>
</td><td><p><code>CIF_MISQUOTED_KEY</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>CIF 2.0 does not allow text blocks to be used as table keys, but this is a somewhat artificial restriction. If the parser encounters a table key quoted with newline/semicolon delimiters then it can recover by accepting that key as valid. </p>
</td></tr>
<tr>
<td><p>Missing text prefix</p>
</td><td><p><code>CIF_MISSING_PREFIX</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>The text prefixing protocol requires every line of a prefixed text field to start with the chosen prefix. If any line fails to do so then the parser can typically recover by simply accepting that line verbatim. </p>
</td></tr>
<tr>
<td><p>Invalid unquoted value</p>
</td><td><p><code>CIF_INVALID_BARE_VALUE</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>A whitespace-delimited data value has a restricted character repertoire and a more-restricted first character. When the parser recognizes that one of these restrictions has not been obeyed, it can recover by accepting the value as-is. </p>
</td></tr>
<tr>
<td><p>Unquoted reserved word</p>
</td><td><p><code>CIF_RESERVED_WORD</code> </p>
</td><td><p>drop </p>
</td></tr>
<tr>
<td colspan="3"><p>The the strings 'data_' (without a block code), 'stop_', and 'global_' are reserved and must not appear as unquoted complete words in CIFs. If the parser encounters one, it can recover by dropping it. </p>
</td></tr>
<tr>
<td><p>Overlength line</p>
</td><td><p><code>CIF_OVERLENGTH_LINE</code> </p>
</td><td><p>drop </p>
</td></tr>
<tr>
<td colspan="3"><p>If a CIF input line exceeds the allowed number of <em>characters</em> (2048 in CIF 1.1 and CIF 2.0) then the parser can recover by ignoring the problem. Note that the limit is expressed in Unicode characters -- not bytes, nor even <code>UChar</code> code units -- and it does not include line terminators. </p>
</td></tr>
<tr>
<td><p>Missing endquote</p>
</td><td><p><code>CIF_MISSING_ENDQUOTE</code> </p>
</td><td><p>assume the quote </p>
</td></tr>
<tr>
<td colspan="3"><p>When a (single-) apostrophe-quoted or quotation-mark-quoted string is not terminated before the end of the line on which it begins, the parser can recover by assuming the missing delimiter at the end of the line.  </p>
</td></tr>
<tr>
<td><p>Unterminated multiline string</p>
</td><td><p><code>CIF_UNCLOSED_TEXT</code> </p>
</td><td><p>assume the closing delimiter </p>
</td></tr>
<tr>
<td colspan="3"><p>When a text block or triple-apostrophe-quoted or triple-quotation-mark-quoted string is not terminated before the end of the end of the input, the parser can recover by assuming the missing delimiter at the end of the input. In such cases, that is often much more text than the value was meant to include, but there is no reliable way to determine where it was supposed to end. </p>
</td></tr>
<tr>
<td><p>Disallowed first character</p>
</td><td><p><code>CIF_DISALLOWED_INITIAL_CHAR</code> </p>
</td><td><p>accept </p>
</td></tr>
<tr>
<td colspan="3"><p>There are slightly different rules for the first character of a CIF than for others, in that a Unicode byte-order mark (U+FEFF) is allowed there. Moreover, an unexpected character at that position can be an indication of a mis-identified character encoding. The parser can recover by accepting the character, but that <em>will</em> result in at least one subsequent error. </p>
</td></tr>
</table>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

