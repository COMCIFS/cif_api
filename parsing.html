<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>cif-api: CIF parsing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="dox.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="parsing">CIF parsing </a></h1><p>The CIF API provides a parser for CIF 2.0, flexible enough to parse CIF 1.1 documents and those complying with earlier CIF conventions as well.</p>
<h2><a class="anchor" id="versions">
CIF versions</a></h2>
<p>To date there have been two formal specifications for the CIF file format, v1.1 and v2.0, and a body of less formal practice predating both. Each specification so far has introduced incompatibilities with preceding practice, so correct parsing depends on correctly identifying the version of CIF with which a given document is intended to conform.</p>
<h3><a class="anchor" id="version_0">
Early CIF</a></h3>
<p>Before the release of the CIF 1.1 specifications, CIF format was defined by the Hall, Allen, and Brown's 1991 paper (Acta Cryst A47, 655-685). It somewhat loosely defines CIF as being composed of "ASCII text", arranged in lines not exceeding 80 characters, with a vague, mostly implicit, sense of some kind of whitespace separating syntactic units (block headers, data names, etc.). The paper makes a point that CIF files are easily readable and suitable for creation or modification via a text editor. There were no save frames, and there was some confusion about exactly which characters were allowed (in particular, about which of the C0 controls were allowed, and what they meant). The vertical tab and form feed characters were accepted by most CIF processors, and the prevailing practice was to treat the latter as a line terminator.</p>
<p>During this time, followup papers refined some of the initial CIF ideas, and ultimately IUCr attempted to bring a little more order to the early CIF world. Significant during this time was limiting the allowed characters in a CIF to the printable subset of those defined by (7-bit) US-ASCII, plus the tab, vertical tab, form feed, carriage return, and line feed control characters (albeit not necessarily <em>encoded</em> according to ASCII). This period was also marked by the development of semantic conventions, on top of basic CIF, for expressing information such as a limited set of non-ASCII characters and logical lines longer than the 80-character limit.</p>
<h3><a class="anchor" id="version_1">
CIF 1.1</a></h3>
<p>The CIF 1.1 specifications were initially drafted in 2002, as a more formal treatment of the language and to address some of the issues that the first ten+ years of CIF practice had uncovered. This revision deleted the vertical tab and form feed characters from the allowed set and extended the line-length limit to 2048 characters. It also, among other things, imposed a 75-character limit on data name, block code, and frame code lengths; allowed save frames (which meanwhile had been added to STAR, along with <code>global_</code> sections), but not save frame references; formally excluded global_ sections (and reserved the "global_" keyword); and restricted the characters that may start an unquoted data value. Significantly, it also introduced the leading CIF version comment, though it is optional in CIF 1.1. With few exceptions, CIF 1.1 did not invalidate pre-existing CIFs.</p>
<h3><a class="anchor" id="version_2">
CIF 2.0</a></h3>
<p>The primary impetus for another CIF revision arose from the concept of adding "methods" to CIF dictionaries, while continuing to express those dictionaries in CIF format. This necessitated support for new data types (list and table) in CIF, and the opportunity was taken to also extend CIF's character repertoire to the whole Unicode space. CIF 2.0 also solves the longstanding issue that even restricting characters to 7-bit ASCII, there are data that cannot be expressed as CIF 1.1 values.</p>
<p>The cost of these changes is a considerably higher level of incompatibility between CIF 2.0 and CIF 1.1 than between CIF 1.1 and previous CIF practice, as reflected by incrementing CIF's major version number. Some data value representations known to appear in well-formed CIF 1.1 documents are not well-formed CIF 2.0; moreover, CIF 2.0 specifies that instance documents must have the form of Unicode text encoded according to UTF-8, which, ironically, makes it a <em>binary</em> format -- albeit one that can do a good impression of a text format on many systems. To assist in sorting this out, CIF 2.0 requires an appropriate version comment to be used in well-formed documents (itself a minor incompatibility).</p>
<h2><a class="anchor" id="parsing-details">
The CIF API parsing interface</a></h2>
<p>The main interface provided for CIF parsing is the <code><a class="el" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&#39;s built-in parser.">cif_parse()</a></code> function, which reads CIF text from a standard C byte stream, checks and interprets the syntax, and optionally records the parsed results in an in-memory CIF object. A variety of options and extension points are available via the <code>options</code> argument to the parse function, falling into two broad categories: </p>
<ul>
<li>options controlling the CIF dialect to be parsed, and </li>
<li>callback functions by which the caller can obtain dynamic information about the progress of the parse, and exert influence on parsing behavior</li>
</ul>
<p>These afford a great deal of parsing flexibility, some dimensions of which are explored in the following sections.</p>
<h3><a class="anchor" id="basic-parsing">
Basic parsing</a></h3>
<p>Historically, a majority of CIF 1.1 parsers have operated by parsing the input into some kind of in-memory representation of the overall CIF, possibly, but not necessarily, independent of the original file. The <code><a class="el" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&#39;s built-in parser.">cif_parse()</a></code> function operates in this way when its third argument points to a location for a CIF handle: </p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">void</span> traditional(FILE *in) {
    <a class="code" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731" title="An opaque handle on a managed CIF.">cif_tp</a> *cif = NULL;

    <a class="code" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&amp;#39;s built-in parser.">cif_parse</a>(in, NULL, &amp;cif);
    <span class="comment">/* results are available via &apos;cif&apos; if anything was successfully parsed */</span>
    <a class="code" href="group__whole__cif__funcs.html#ga4781ccd52bdc70271b44e6648f3ea41a" title="Removes the specified managed CIF, releasing all resources it holds.">cif_destroy</a>(cif);  <span class="comment">/* safe even if &apos;cif&apos; is still NULL */</span>
}
</pre></div><p>By default, however, the parser stops at the first error it encounters. Inasmuch as historically, many CIFs have contained at least minor errors, it may be desirable to instruct the parser to attempt to push past all or certain kinds of errors, extracting <a class="el" href="error_recovery.html">a best-guess interpretation of the remainder of the input</a>. Such behavior can be obtained by providing an error-handling callback function of type matching <code>cif_parse_error_callback_tp</code> . Such a function serves not only to control which errors are bypassed, but also, if so written, to pass on details of each error to the caller. For example, this code counts the number of CIF syntax and semantic errors in the input CIF: </p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">int</span> record_error(<span class="keywordtype">int</span> error_code, <span class="keywordtype">size_t</span> line, <span class="keywordtype">size_t</span> column, <span class="keyword">const</span> UChar *text, <span class="keywordtype">size_t</span> length, <span class="keywordtype">void</span> *data) {
    *((<span class="keywordtype">int</span> *) data) += 1;
    <span class="keywordflow">return</span> <a class="code" href="group__return__codes.html#ga924dd949aa6947e1fb4548ce29a21996" title="A result code indicating successful completion of the requested operation.">CIF_OK</a>;
}

<span class="keywordtype">void</span> count_errors(FILE *in) {
    <a class="code" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731" title="An opaque handle on a managed CIF.">cif_tp</a> *cif = NULL;
    <span class="keywordtype">int</span> num_errors = 0;
    <span class="keyword">struct </span><a class="code" href="structcif__parse__opts__s.html" title="Represents a collection of CIF parsing options.">cif_parse_opts_s</a> *opts = NULL;

    <a class="code" href="group__cifio__funcs.html#ga9a62365d8a9c9c000b6c3871ef3879d1" title="Allocates a parse options structure and initializes it with default values.">cif_parse_options_create</a>(&amp;opts);
    opts-&gt;<a class="code" href="structcif__parse__opts__s.html#a96747877315cb02b78779f862ca86d1e" title="A callback function by which the client application can be notified about parse errors...">error_callback</a> = record_error;
    opts-&gt;<a class="code" href="structcif__parse__opts__s.html#a66b7d5cb3d1244e724a7f15aa9b02c4f" title="A pointer to user data to be forwarded to all callback functions invoked by the parser;...">user_data</a> = &amp;num_errors;
    <a class="code" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&amp;#39;s built-in parser.">cif_parse</a>(in, opts, &amp;cif);
    free(opts);
    <span class="comment">/*</span>
<span class="comment">     * the parsed results are available via &apos;cif&apos;</span>
<span class="comment">     * the number of errors is available in &apos;num_errors&apos;</span>
<span class="comment">     */</span>
    <span class="comment">/* ...  */</span>
    <a class="code" href="group__whole__cif__funcs.html#ga4781ccd52bdc70271b44e6648f3ea41a" title="Removes the specified managed CIF, releasing all resources it holds.">cif_destroy</a>(cif);
}
</pre></div><p>For convenience, the CIF API provides two default error handler callback functions, <code><a class="el" href="group__cifio__funcs.html#ga0b6868dbab8cb460f2afa55b0f6e9e98" title="A CIF parse error handler function that interrupts the parse on any error, returning...">cif_parse_error_die()</a></code> and <code><a class="el" href="group__cifio__funcs.html#ga496775864901244b64abcc63fe2bbb5a" title="A CIF parse error handler function that ignores all errors.">cif_parse_error_ignore()</a></code>. As their names imply, the former causes the parse to be aborted on any error (the default behavior), whereas the latter causes all errors to silently be ignored (to the extent that is possible).</p>
<h3><a class="anchor" id="parser-callbacks">
Parser callbacks</a></h3>
<p>Parsing a CIF from an external representation is in many ways analogous to performing a depth-first traversal of a pre-parsed instance of the CIF data model, as the <code><a class="el" href="group__whole__cif__funcs.html#ga4773f5b0646e96e25d0f712c011f8bb1" title="Performs a depth-first, natural-order traversal of a CIF, calling back to handler...">cif_walk()</a></code> function does. In view of this similarity, a <code><a class="el" href="structcif__handler__tp.html" title="A set of functions defining a handler interface for directing and taking appropriate...">cif_handler_tp</a></code> object such as is also used with <code><a class="el" href="group__whole__cif__funcs.html#ga4773f5b0646e96e25d0f712c011f8bb1" title="Performs a depth-first, natural-order traversal of a CIF, calling back to handler...">cif_walk()</a></code> can be provided among the parse options to facilitate caller monitoring and control of the parse process. The handler callbacks can probe and to some extent modify the CIF as it is parsed, including by instructing the parser to suppress (but not altogether skip) some portions of the input. This facility has applications from parse-time data selection to validation and beyond; for example, here is a naive approach to assigning loop categories based on loop data names: </p>
<div class="fragment"><pre class="fragment">
<span class="keywordtype">int</span> assign_loop_category(<a class="code" href="group__datatypes.html#gacedb378f63a1980e4235c470b622e335" title="An opaque handle on a managed CIF loop.">cif_loop_tp</a> *loop, <span class="keywordtype">void</span> *context) {
    UChar **names;
    UChar **next;
    UChar *dot_location;
    <span class="keyword">const</span> UChar unicode_dot = 0x2E;

    <span class="comment">/* We can rely on at least one data name */</span>
    <a class="code" href="group__loop__funcs.html#ga5f35b99d2227d352043e7495fca575da" title="Retrieves the item names belonging to the specified loop.">cif_loop_get_names</a>(loop, &amp;names);
    <span class="comment">/*</span>
<span class="comment">     * Assumes the name contains a decimal point (Unicode code point U+002E), and</span>
<span class="comment">     * takes the category as everything preceding it.  Ignores case sensitivity considerations.</span>
<span class="comment">     */</span>
    dot_location = u_strchr(names[0] + 1, unicode_dot);
    *dot_location = 0;
    <a class="code" href="group__loop__funcs.html#ga484e7364617decceda7050096833d7bb" title="Sets the specified loop&amp;#39;s category.">cif_loop_set_category</a>(loop, names[0]);
    <span class="comment">/* Clean up */</span>
    <span class="keywordflow">for</span> (next = names; *next != NULL; next += 1) {
        free(*next);
    }
    free(names);
}

<span class="keywordtype">void</span> parse_with_categories(FILE *in) {
    <a class="code" href="group__datatypes.html#ga118532ee38b48f9879f2e18e18402731" title="An opaque handle on a managed CIF.">cif_tp</a> *cif = NULL;
    <span class="keyword">struct </span><a class="code" href="structcif__parse__opts__s.html" title="Represents a collection of CIF parsing options.">cif_parse_opts_s</a> *opts = NULL;
    <a class="code" href="structcif__handler__tp.html" title="A set of functions defining a handler interface for directing and taking appropriate...">cif_handler_tp</a> <a class="code" href="structcif__parse__opts__s.html#a4508b10109b811a30c950500a9234cfe" title="A set of handler functions by which the application can be notified of details of...">handler</a> = { NULL, NULL, NULL, NULL, NULL, NULL, assign_loop_category, NULL, NULL, NULL, NULL };

    <a class="code" href="group__cifio__funcs.html#ga9a62365d8a9c9c000b6c3871ef3879d1" title="Allocates a parse options structure and initializes it with default values.">cif_parse_options_create</a>(&amp;opts);
    opts-&gt;<a class="code" href="structcif__parse__opts__s.html#a4508b10109b811a30c950500a9234cfe" title="A set of handler functions by which the application can be notified of details of...">handler</a> = &amp;handler;
    <a class="code" href="group__cifio__funcs.html#gaa63c92a58e9b58d368b161bd0741d64c" title="Parses a CIF from the specified stream using the library&amp;#39;s built-in parser.">cif_parse</a>(in, opts, &amp;cif);
    free(opts);
    <span class="comment">/* the parsed results are available via &apos;cif&apos; */</span>
    <span class="comment">/* ... */</span>
    <a class="code" href="group__whole__cif__funcs.html#ga4781ccd52bdc70271b44e6648f3ea41a" title="Removes the specified managed CIF, releasing all resources it holds.">cif_destroy</a>(cif);
}
</pre></div><p>Note that the parser traverses its input and issues callbacks in document order, from start to end, so unlike <code><a class="el" href="group__whole__cif__funcs.html#ga4773f5b0646e96e25d0f712c011f8bb1" title="Performs a depth-first, natural-order traversal of a CIF, calling back to handler...">cif_walk()</a></code>, it does not guarantee to traverse all of a data block's save frames before any of its data.</p>
<h4><a class="anchor" id="validation">
CIF validation</a></h4>
<p>The CIF API does not provide specific support for CIF validation because validation is dependent on the DDL of the dictionary to which a CIF purports to comply, whereas the CIF API is generic, not specific to any particular DDL or dictionary. To the extent that some validations can be performed during parsing, however, callback functions provide a suitable means for interested applications to engage such validation.</p>
<h4><a class="anchor" id="comments">
Comments</a></h4>
<p>For the most part, the parser ignores CIF comments other than for attempting to identify the CIF version with which its input purports to comply. In the event that the caller wants to be informed of comments and other whitespace, however, there is among the parse options a pointer to a callback function for that purpose. Its use is analogous to the callbacks already discussed.</p>
<h3><a class="anchor" id="syntax-only">
Syntax-only parsing</a></h3>
<p>For some applications, it might not be desirable or even feasible to collect parsed CIF content into an in-memory representation. The simplest such application performs only a syntax check of the input -- perhaps to test compliance with a particular CIF version and/or parse options. The parser function operates in just that way when its third argument is NULL (that is, when the caller provides no CIF handle location). All provided callbacks are invoked as normal in this mode, including any error callback, and regardless of any callbacks, the parser's return code indicates whether any errors were detected. This syntax-only parsing mode does have a few limitations, however: primarily that because it does not retain an in-memory representation of its input, it cannot check CIF semantic requirements for data name, frame code, and block code uniqueness within their respective scopes.</p>
<h3><a class="anchor" id="event-driven">
Event-driven parsing</a></h3>
<p>The availability and scope of callback functions make the syntax-only mode described above a CIF analog of the event-driven "SAX" XML parsing interface. To use the parser in that mode, the caller provides callback functions by which to be informed of parse "events" of interest -- recognition of entities and entity boundaries -- so as to extract the desired information during the parse instead of by afterward analyzing the parsed result. Callbacks can communicate with themselves and each other, and can memorialize data for the caller, via the <code>user_data</code> object provided among the parse options (and demonstrated in the error-counting example). Callbacks can be omitted for events that are not of interest. </p>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr/>
<p style="font-size: small">Copyright 2014, 2015 John C. Bollinger</p>

